#!/usr/bin/env php
<?php
/**
 * @file
 * The FolderShare web services (REST) client application.
 *
 * DO NOT EDIT THIS FILE!
 *
 * This file has been built automatically by concatenating a set of
 * separate source files in order to create a single stand-alone
 * application. If you need to modify this application, you should
 * edit the source files instead, then re-concatenate them into a
 * new application.
 *
 * This file contains the following source files:
 *   src/FolderShareConnect.php
 *   src/FolderShareFormat.php
 *   src/foldershare.php
 *
 * Built on: Tue Jan 23 13:09:33 PST 2018
 */


/**
 * Manages communications with a web site using the FolderShare Drupal module.
 *
 * This class handles client-server communications for client applications
 * communicating with a remote server running the Drupal content management
 * system and the FolderShare module. Drupal manages the content and provides
 * a general-purpose web services (i.e. "REST") interface. FolderShare
 * supports that interface in its management of a hierarchy of files and
 * folders stored on the server.
 *
 * This class's methods configure the client-server communications path,
 * then use that path to send requests to the server and handle responses
 * back from the server. The requests supported here include:
 *
 * - Create folders.
 * - Upload files and folders.
 * - Download files and folders.
 * - Get lists of files and folders.
 * - Search files and folders.
 * - Get file and folder names and other descriptive values.
 * - Rename and edit file and folder description values.
 * - Copy and move files and folders.
 * - Delete files and folders.
 * - Get FolderShare settings.
 * - Get web site settings related to these services.
 *
 * <B>Web server setup</B><BR>
 * In order for this class to communicate with a web server, the following
 * must have been configured by the site administrator on that server:
 *
 * - The site must be running the Drupal content management system.
 *
 * - The FolderShare module for Drupal must be installed.
 *
 * - The Drupal REST services module must be installed.
 *
 * - The FolderShare resource for REST must be enabled and configured to
 *   enable:
 *   - GET, POST, PATCH, and DELETE methods.
 *   - The JSON serialization format.
 *   - An authentication service (such as basic authentication).
 *
 * Applications may use this class to open a connection to a web server,
 * authenticate the user across that connection, then issue
 * one or more requests on the connection. The connection is automatically
 * closed when the connection object is deleted.
 *
 * <B>Return formats</B><BR>
 * Many requests can return information to the client in one of these formats:
 *
 * - 'full' returns a complex serialized entity or list of entities as an
 *   associative array of fields that each containing an array of values,
 *   which may in turn include on or more named values that may be scalars
 *   or further arrays. This structure matches the layout of data on the
 *   server and it is suitable for re-use in a future call to create or
 *   update a file or folder. However, it is not very user-friendly.
 *
 * - 'keyvalue' returns a simply serialized entity as an associative array
 *   of field names that each contain either a scalar value or an array of
 *   scalar values. The key-value array is easier to process by client
 *   code and it can be converted to a user-friendly output.
 */
class FolderShareConnect {

  /*--------------------------------------------------------------------
   *
   * Version.
   *
   *--------------------------------------------------------------------*/

  /**
   * The version number of this class.
   */
  const VERSION = '0.4.0 (January 2018)';

  /*--------------------------------------------------------------------
   *
   * Authentication constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * A connection authentication type that does no authentication.
   *
   * This value is a default until a specific authentication style has
   * been set up.  However, most web sites will not allow connections
   * without authentication.
   *
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::login()
   */
  const AUTHENTICATION_NONE = 0;

  /**
   * A basic authentication type that uses a user name and password.
   *
   * Drupal core supports basic authentication, and it is this style that
   * is mostly widely used for web services. With basic authentication,
   * the caller of this class provides a user name and password that are
   * included on every request to the server.
   *
   * Basic authentication can fail if the user name and password
   * are invalid.
   *
   * When a connection uses SSL encryption, the user name and password
   * are included in the encrypted content so they cannot be seen by
   * intermediate parties.
   *
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_BASIC = 1;

  /**
   * A cookie authentication type that uses a session cookie.
   *
   * Drupal core supports cookie authentication, and it is this style
   * that is used by web browsers. With cookie authentication, the
   * caller of this class provides a user name and password that are
   * used for an initial connection to the server. The server returns
   * a session cookie and that cookie is used for further requests.
   *
   * Cookie authentication can fail if the session cookie cannot be
   * obtained. This can happen if the server has been configured to use a
   * non-standard user login form, such as one that requires a CAPTCHA.
   *
   * Cookie authentication can also fail if the user name and password
   * are invalid.
   *
   * When a connection uses SSL encryption, the user name and password
   * are included in the encrypted content so they cannot be seen by
   * intermediate parties.
   *
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_COOKIE = 2;

  /**
   * A cookie or basic authentication type.
   *
   * This authentication type encompasses both AUTHENTICATION_COOKIE and
   * AUTHENTICATION_BASIC types. When a connection is first established,
   * this class tries to use cookie authentication to log in the user.
   * If that works, subsequent requests use the session cookie returned by
   * that authentication process. But if cookie authentication fails,
   * this class fails-over to basic authentication and tries sending the
   * user name and password on all subsequent requests.
   *
   * When a connection uses SSL encryption, the user name and password
   * are included in the encrypted content so they cannot be seen by
   * intermediate parties.
   *
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_AUTO = 3;

  /**
   * The order of authentication types tried for AUTHENTICATION_AUTO.
   *
   * When the requested authentication type is AUTHENTICATION_AUTO, the
   * class automatically cycles through authentication types. Each type
   * is checked, in the order here, to find the first one that works.
   *
   * @see ::getAuthenticationType()
   * @see ::getAuthenticationTypeName()
   * @see ::getPassword()
   * @see ::getUserName()
   * @see ::login()
   */
  const AUTHENTICATION_AUTO_ORDER = [
    self::AUTHENTICATION_COOKIE,
    self::AUTHENTICATION_BASIC,
  ];

  /*--------------------------------------------------------------------
   *
   * Login state constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * An authentication status indicating the user is not logged in.
   *
   * This is the state for the connection before a login is performed.
   *
   * @see ::login()
   */
  const STATUS_NOT_LOGGED_IN = 0;

  /**
   * An authentication status indicating user login is pending.
   *
   * The pending state is used when login credentials have been set, but
   * no request using them has been made yet. Once a request has successfully
   * used them, the login status changes to STATUS_LOGGED_IN.
   *
   * This state is only used by AUTHENTICATION_BASIC.
   *
   * @see ::login()
   */
  const STATUS_PENDING = 1;

  /**
   * An authentication status indicating user login failed.
   *
   * This state indicates that login credentials were set and tried, but
   * failed.
   *
   * @see ::login()
   */
  const STATUS_FAILED = 2;

  /**
   * An authentication status indicating the user is logged in.
   *
   * This state indicates that authentication was performed successfully.
   *
   * @see ::login()
   */
  const STATUS_LOGGED_IN = 3;

  /*--------------------------------------------------------------------
   *
   * URL constants.
   *
   *--------------------------------------------------------------------*/

  /**
   * The URL path for requesting a CSRF token.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff").
   *
   * This path is defined within Drupal core's REST services module and
   * cannot be changed.
   */
  const URL_CSRF_TOKEN = '/session/token';

  /**
   * The URL path for logging in using cookie authentication.
   *
   * This path is defined within Drupal core's User module and cannot
   * be changed.
   */
  const URL_USER_LOGIN = '/user/login';

  /**
   * The URL path for logging out using cookie authentication.
   *
   * This path is defined within Drupal core's User module and cannot
   * be changed.
   */
  const URL_USER_LOGOUT = '/user/logout';

  /**
   * The URL path for an HTTP GET request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff"). An entity ID and format query will be added.
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_GET = '/foldershare';

  /**
   * The URL path for an HTTP DELETE request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff"). An entity ID will be added.
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_DELETE = '/foldershare';

  /**
   * The URL path for an HTTP PATCH request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff"). An entity ID and format query will be added.
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_PATCH = '/foldershare';

  /**
   * The URL path for an HTTP POST request.
   *
   * The path only contains the string following the scheme, domain, and
   * optional port on a URL (e.g. for "http://example:80/stuff", only
   * include "stuff").
   *
   * This path is defined within the FolderShare resource for REST and
   * cannot be changed.
   */
  const URL_POST = '/entity/foldershare';

  /**
   * The URL path for an HTTP POST request to upload a file or folder.
   *
   * The path leads to an upload form instead of to the REST resource
   * because the REST module currently does not support base class
   * features needed for file upload.
   *
   * This path is defined within the FolderShare module and cannot be
   * changed.
   */
  const URL_UPLOAD = '/foldershare/upload';

  /*--------------------------------------------------------------------
   *
   * Fields
   *
   *--------------------------------------------------------------------*/

  /**
   * When TRUE, this class writes status messages to STDERR.
   *
   * @var string
   * @see ::isVerbose()
   * @see ::setVerbose()
   */
  protected $verbose;

  /**
   * The host name (and optional port) for the web site.
   *
   * During use, the URL will have Drupal routes added that lead to
   * REST resources.
   *
   * @var string
   * @see ::getHostName()
   * @see ::setHostName()
   */
  protected $hostName;

  /**
   * The authentication type.
   *
   * This is one of AUTHENTICATION_NONE, AUTHENTICATION_BASIC, or
   * AUTHENTICATION_COOKIE.
   *
   * @var int
   * @see ::getUserName()
   * @see ::getPassword()
   * @see ::getAuthenticationType()
   * @see ::setUserNameAndPassword()
   */
  protected $authenticationType;

  /**
   * The user name if using basic or cookie authentication.
   *
   * When using basic authentication, the user name and password are
   * sent on every request to the server. When using cookie authentication,
   * the user name and password are only sent on an initial login request,
   * which returns a session cookie used for all further requests.
   *
   * @var string
   * @see ::getUserName()
   * @see ::setUserNameAndPassword()
   */
  protected $userName;

  /**
   * The user password if using basic or cookie authentication.
   *
   * When using basic authentication, the user name and password are
   * sent on every request to the server. When using cookie authentication,
   * the user name and password are only sent on an initial login request,
   * which returns a session cookie used for all further requests.
   *
   * @var string
   * @see ::getPassword()
   * @see ::setUserNameAndPassword()
   */
  protected $password;

  /**
   * The CSRF token, or NULL if empty.
   *
   * The "Cross-Site-Request-Forgery" (CSRF) token is retrieved from
   * the server on the first request to the server. The token is then
   * attached to all further non-safe requests to the same server
   * (e.g. for posts, patches, and deletes, but not gets).
   *
   * @var string
   * @see ::clearCSRFToken()
   * @see ::getCSRFToken()
   */
  protected $csrfToken;

  /**
   * The logout token when using cookies.
   *
   * @var string
   */
  protected $cookieLogoutToken;

  /**
   * Whether the user's credentials have been authenticated (logged in).
   *
   * @var int
   * @see ::STATUS_NOT_LOGGED_IN
   * @see ::STATUS_PENDING
   * @see ::STATUS_FAILED
   * @see ::STATUS_LOGGED_IN
   */
  protected $authenticationStatus;

  /**
   * The CURL session handle after it has been initialized.
   *
   * The session handle is created when an object of this class is
   * constructed, and released when the object is destroyed.
   *
   * @var resource
   */
  protected $curlSession;

  /**
   * A flag indicating that server communications has been validated.
   *
   * This flag is initialized to FALSE when an object of this class is
   * constructed, and it is reset to FALSE any time the host name is
   * changed. The flag is set to TRUE by verifyServer() prior, which
   * issues intial communications to the server before the caller of
   * this class makes their first request.
   *
   * @var bool
   * @see ::verifyServer()
   */
  protected $serverVerified;

  /**
   * The list of HTTP verbs supported by the remote site.
   *
   * The string array is changed from empty to a list of the names of
   * supported HTTP verbs when the server connection is verified on the
   * first request. HTTP verbs are always in upper case and one of the
   * following values:
   * - GET.
   * - DELETE.
   * - PATCH.
   * - POST.
   *
   * This list of supported HTTP verbs is checked on each call to this
   * class before trying to send the request. If the verb is not supported,
   * the request is aborted.
   *
   * Typically, servers support all of the above HTTP verbs.
   *
   * @var string[]
   * @see ::verifyServer()
   * @see ::getHttpVerbs()
   */
  protected $httpVerbs;

  /**
   * The current preferred format for content returned by the server.
   *
   * Some requests to the server return content, such as the list of fields
   * in a FolderShare entity (a file or folder). The format of that
   * returned content can vary depending upon the selected return format:
   * - 'full' = returns a full detailed entity or list of entities.
   * - 'keyvalue' = returns a simplified entity or list of entities.
   *
   * @var string
   * @see ::setReturnFormat()
   * @see ::getReturnFormat()
   */
  protected $format;

  /**
   * The most recent download file name.
   *
   * During a file download from the server, an HTTP header callback invoked
   * by CURL looks for the "Content-Disposition" header line that names the
   * file being downloaded. If found, the name is saved to this field where
   * it is used at the end of the download to rename the file saved to local
   * storage.
   *
   * @var string
   * @see ::download()
   * @see ::downloadHeaderCallback()
   */
  private $downloadFilename;

  /*--------------------------------------------------------------------
   *
   * Construction & Destruction.
   *
   *--------------------------------------------------------------------*/

  /**
   * Creates a new connection ready to communicate to a remote host.
   *
   * Constructing an object of this class initializes internal state, but
   * does not open a connection to a server yet. The caller must set
   * the host name and, if needed, the authentication credentials to use.
   * Thereafter, methods that request data from the server open the
   * connection and send and receive the appropriate data.
   *
   * @see ::setHostName()
   * @see ::setUserNameAndPassword()
   */
  public function __construct() {
    if (function_exists('curl_init') === FALSE) {
      throw new \RuntimeException(
        "The PHP CURL package is required, but not installed.\nThis application cannot continue without it.");
    }

    $this->authenticationType = self::AUTHENTICATION_NONE;
    $this->authenticationStatus = self::STATUS_NOT_LOGGED_IN;
    $this->userName = '';
    $this->password = '';
    $this->format = 'full';
    $this->verbose = FALSE;
    $this->clearCSRFToken();
    $this->unverifyServer();

    $this->curlSession = curl_init();
  }

  /**
   * Closes the connection to the remote server.
   *
   * If the user is logged in, they are logged out first.
   */
  public function __destruct() {
    $this->logout();
    curl_close($this->curlSession);
  }

  /*--------------------------------------------------------------------
   *
   * Verbosity.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns TRUE if the connection has been set to be verbose.
   *
   * When the connection is verbose, status messages are written to STDERR
   * for each operation. This is useful when debugging, but probably not
   * a feature users will enjoy.
   *
   * @return bool
   *   Returns TRUE if the connection is verbose.
   *
   * @see ::setVerbose()
   */
  public function isVerbose() {
    return $this->verbose;
  }

  /**
   * Sets whether the connection is verbose.
   *
   * When the connection is verbose, status messages are written to STDERR
   * for each operation. This is useful when debugging, but probably not
   * a feature users will enjoy.
   *
   * @param bool $verbose
   *   Sets the connection's verbosity to TRUE (verbose) or FALSE (not).
   *
   * @see ::isVerbose()
   */
  public function setVerbose(bool $verbose) {
    $this->verbose = $verbose;
  }

  /**
   * Prints a message to STDERR if verbosity is enabled.
   *
   * @param string $message
   *   The message to print if verbosity is enabled.
   */
  protected function printVerbose(string $message) {
    if ($this->verbose === TRUE && empty($message) === FALSE) {
      fwrite(STDERR, "FolderShareConnect: $message\n");
    }
  }

  /*--------------------------------------------------------------------
   *
   * Host.
   *
   *--------------------------------------------------------------------*/

  /**
   * Gets the name of the host and an optional port for the connection.
   *
   * The host name selects the site with which this connection communicates.
   * Host names are typically a simple string like "example.com", but they
   * optionally may include a port number for the web server, such as
   * "example.com:80".
   *
   * @return string
   *   The host name and optional port for the web site.
   *
   * @see ::setHostName()
   */
  public function getHostName() {
    return $this->hostName;
  }

  /**
   * Sets the host name and an optional port for the connection.
   *
   * The host name selects the site with which this connection communicates.
   * Host names are typically a simple string like "example.com", but they
   * optionally may include a port number for the web server, such as
   * "example.com:80".
   *
   * Setting the host name is normally done immediately after constructing
   * the connection and before issuing any requests. If the host name is
   * changed later, the user is logged out and the connection reset.
   *
   * @param string $hostName
   *   The host name and optional for the web site.
   *
   * @see ::getHostName()
   * @see ::logout()
   */
  public function setHostName(string $hostName) {
    $this->logout();
    $this->hostName = $hostName;
    $this->clearCSRFToken();
    $this->unverifyServer();
  }

  /*--------------------------------------------------------------------
   *
   * Authentication.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns the authentication type in use.
   *
   * The authentication type is set at login as one of:
   * - ATHENTICATION_NONE = there is no user authentication.
   * - ATHENTICATION_BASIC = authentication uses a user name and password.
   * - ATHENTICATION_COOKIE = authentication uses a session cookie along
   *   with a user name and password.
   *
   * The special AUTHENTICATION_AUTO selects automatic negotiation among
   * supported authentication methods. After authentication, the
   * authentication type will be set to the type used.
   *
   * @return int
   *   Returns the authentication type.
   *
   * @see ::AUTHENTICATION_NONE
   * @see ::AUTHENTICATION_BASIC
   * @see ::AUTHENTICATION_COOKIE
   * @see ::AUTHENTICATION_AUTO
   */
  public function getAuthenticationType() {
    return (int) $this->authenticationType;
  }

  /**
   * Returns a human-friendly name string for the authentication type.
   *
   * @param int $authenticationType
   *   The authentication type to translate into a name string.
   *
   * @return string
   *   Returns a human-friendly name for the authentication type.
   */
  public function getAuthenticationTypeName(int $authenticationType) {
    switch ($authenticationType) {
      case self::AUTHENTICATION_NONE:
        return "No Authentication";

      case self::AUTHENTICATION_BASIC:
        return "Basic Authentication";

      case self::AUTHENTICATION_COOKIE:
        return "Cookie Authentication";

      case self::AUTHENTICATION_AUTO:
        return "Automatic Authentication";

      default:
        return "Unknown Authentication $authenticationType";
    }
  }

  /**
   * Gets the user name, if set, when using basic and cookie authentication.
   *
   * The user name is set at login.
   *
   * @return string
   *   Returns the current user name.
   *
   * @see ::getPassword()
   * @see ::login()
   * @see ::logout()
   */
  public function getUserName() {
    return $this->userName;
  }

  /**
   * Gets the password, if set, when using basic and cookie authentication.
   *
   * The password is set at login.
   *
   * @return string
   *   Returns the current password.
   *
   * @see ::getUserName()
   * @see ::login()
   * @see ::logout()
   */
  public function getPassword() {
    return $this->password;
  }

  /**
   * Returns TRUE if the user is logged in.
   *
   * A connection is logged in if credentials were supplied to login()
   * and those credentials have been confirmed by the server. Confirmation
   * is performed differently for different authentication types:
   * - AUTHENTICATION_NONE: credentials are never confirmed and this
   *   function always returns FALSE.
   * - AUTHENTICATION_COOKIE: credentials are confirmed at login().
   * - AUTHENTICATION_BASIC: credentials are confirmed on the first request
   *   after login().
   *
   * @return bool
   *   Returns TRUE if the connection has been logged in, and FALSE
   *   otherwise.
   */
  public function isLoggedIn() {
    switch ($this->authenticationStatus) {
      default:
      case self::STATUS_NOT_LOGGED_IN:
      case self::STATUS_PENDING:
      case self::STATUS_FAILED:
        return FALSE;

      case self::STATUS_LOGGED_IN:
        return TRUE;
    }
  }

  /**
   * Returns a human-friendly name string for the authentication status.
   *
   * @param int $authenticationStatus
   *   The authentication status to translate into a name string.
   *
   * @return string
   *   Returns a human-friendly name for the authentication status.
   */
  protected function getAuthenticationStatusName(int $authenticationStatus) {
    switch ($authenticationStatus) {
      case self::STATUS_NOT_LOGGED_IN:
        return "Not logged in";

      case self::STATUS_PENDING:
        return "Login pending";

      case self::STATUS_FAILED:
        return "Login failed";

      case self::STATUS_LOGGED_IN:
        return "Logged in";

      default:
        return "Unknown authentication status $authenticationStatus";
    }
  }

  /*--------------------------------------------------------------------
   *
   * Configuration.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns the currently selected format for returned data.
   *
   * For requests that return data, that data is returned as an associative
   * array in one of two formats:
   * - 'full' = returns a full detailed entity or list of entities.
   * - 'keyvalue' = returns a simplified entity or list of entities.
   *
   * @return string
   *   The name of a server-known format for returned data.
   *
   * @see ::setReturnFormat()
   */
  public function getReturnFormat() {
    return $this->format;
  }

  /**
   * Sets the currently selected format for returned data.
   *
   * For requests that return data, that data is returned as an associative
   * array in one of two formats:
   * - 'full' = returns a full detailed entity or list of entities.
   * - 'keyvalue' = returns a simplified entity or list of entities.
   *
   * @param string $format
   *   The name of a server-known format for returned data.
   *
   * @see ::getReturnFormat()
   */
  public function setReturnFormat(string $format) {
    $this->format = $format;
  }

  /*--------------------------------------------------------------------
   *
   * Error messages.
   *
   *--------------------------------------------------------------------*/

  /**
   * Returns a nicer CURL error message.
   *
   * CURL errors indicate a communications problem. For all errors, CURL can
   * provide a brief error message, but these messages are rarely sufficient
   * to explain to a user what is going on and what they can do about it.
   *
   * This method maps selected error numbers to friendlier error messages.
   * If the error number is not recognized, the default CURL error message
   * is returned.
   *
   * @param int $errno
   *   The CURL error number.
   *
   * @return string
   *   Returns a friendly error message.
   */
  protected function getNiceCurlErrorMessage(int $errno) {
    switch ($errno) {
      case CURLE_URL_MALFORMAT:
        return
"The host name is not in the proper format.
Please check that the name does not include a '/', space, or other special
characters.";

      case CURLE_URL_MALFORMAT_USER:
      case CURLE_MALFORMAT_USER:
        return
"The user name is not in the proper format.
Please check that the name does not include a ':', space, or other special
characters.";

      case CURLE_COULDNT_RESOLVE_HOST:
        return
"The host could not be found.
Please check your host name for typos.";

      case CURLE_HTTP_PORT_FAILED:
        $colonIndex = mb_strpos($this->hostName, ':');
        if ($colonIndex === FALSE) {
          return
"The host refused a connection on the default port 80.
The host may not support web service access or it may require a different port.
You may specify a port by adding ':' and a port number to the end of the host
name (e.g. 'example.com:1234').";
        }

        $port = mb_substr($this->hostName, ($colonIndex + 1));
        return
"The host refused a connection on the specified port $port.
Please check that the port number is correct.";

      case CURLE_COULDNT_CONNECT:
      case CURLE_OPERATION_TIMEOUTED:
        return
"The host is not responding.
The host may be down, there could be a network problem, or the host may
not support the network connections required by this application.";

      case CURLE_BAD_PASSWORD_ENTERED:
        return
"The host denied access because the user name or password is incorrect.
Please check your user name and password for typos.";

      case CURLE_REMOTE_ACCESS_DENIED:
        return
"The host denied access.
The host may not support web service access, or the user name and password
may not grant sufficient permission to respond to your request.";

      case CURLE_TOO_MANY_REDIRECTS:
        return
"There is a communications problem with the host.
The host is repeatedly redirecting requests to another host, or to the
same host in a never-ending cycle. Please report this to the host's
administrator.";

      case CURLE_SEND_ERROR:
        return
"The host unexpectedly stopped receiving requests.
The host may have gone down or there could be a network problem.";

      case CURLE_RECV_ERROR:
        return
"The host unexpectedly stopped sending information.
The host may have gone down or there could be a network problem.";

      case CURLE_FILESIZE_EXCEEDED:
        return
"The host reported that the file size was too large.
The file may be too large to transfer.";

      case CURLE_PARTIAL_FILE:
        return
"The host failed to send the entire file.
The host may be busy, there may be a connection problem, or the file may
be too large to transfer reliably.";

      default:
        return curl_error($this->curlSession);
    }
  }

  /**
   * Returns a nicer HTTP error message.
   *
   * Web servers that respond with an error HTTP code may or may not include
   * a message with that code. If they do not, this method returns a nicer
   * message for a variety of common HTTP codes.
   *
   * @param int $httpCode
   *   The HTTP code.
   *
   * @return string
   *   Returns friendlier error message.
   */
  protected function getNiceHttpErrorMessage(int $httpCode) {
    //
    // The list below is intentionally incomplete. HTTP codes that are not
    // likely for requests issued by this class are not included. For
    // instance, codes associated with WebDAV, IM, and proxies are not
    // included.
    //
    switch ($httpCode) {
      case 200:
        // OK.
        return
"The request succeeded.";

      case 201:
        // Created.
        return
"The request to create content succeeded.";

      case 202:
        // Accepted.
        return
"The request was accepted and processing is in progress.";

      case 204:
        // No content.
        return
"The request succeeded and, as expected, no content was returned.";

      case 400:
        // Bad request.
        return
"There is a problem with the request.
The host rejected the request because it is too large or it is improperly
formatted. This is probably a programming error. Please contact the
developers of this software.";

      case 401:
        // Unauthorized. This really should be handled outside this method
        // so that the server's response header can be considered.
        return
"The host has denied access.
The host may require additional authentication or the host may be blocking
access from your local host or network.";

      case 403:
        // Forbidden.
        return
"The host denied access. You do not have permission for this request.";

      case 404:
        // Not found.
        return
"The requested information could not be found.";

      case 405:
        // Method not allowed.
        return
"The host does not support this type of information request.";

      case 406:
        // Not acceptable.
        return
"The host does not support information interchange in a format recognized
by this application.";

      case 408:
        // Request timeout.
        return
"The host is unexpectedly not responding.
The host may have gone down, there could be a network problem, or the
host may have had a problem with the request.";

      case 410:
        // Gone.
        return
"The requested information is no longer available.";

      case 429:
        // Too many requests.
        return
"The host is declining connections because of too many requests.
The host is rate limiting its communications and the number of requests has
exceeded that limit.";

      case 500:
        // Internal server error.
        return
"The host encountered an unknown internal error.
If this continues, please report this to the host's administrator.";

      case 503:
        // Service unavailable.
        return
"The host's services are temporarily unavailable.
Please check back later.";

      default:
        // All other error codes are obscure. Return a generic message.
        return
"The host responded with an unexpected HTTP error code: $httpCode.\n";
    }
  }

  /*--------------------------------------------------------------------
   *
   * Utilities.
   *
   * The miscellaneous functions here provide mixed functionality to
   * later code.
   *
   *--------------------------------------------------------------------*/

  /**
   * Creates an empty dummy entity.
   *
   * During POST and PATCH operations, a new entity and fields are required
   * in the request. If the operation does not need a detailed entity, or if
   * the caller does not provide one, this dummy entity is used.
   *
   * @return array
   *   Returns a dummy entity array with well-known fields and no values.
   */
  protected function createDummyEntity() {
    return [
      'name' => [],
      /*
      'uid' => [],
      'created' => [],
      'changed' => [],
      'description' => [],
      'kind' => [],
      'mime' => [],
      'parentid' => [],
      'rootid' => [],
      'size' => [],
      'file' => [],
      'image' => [],
      'media' => [],
      'grantauthoruids' => [],
      'grantviewuids' => [],
       */
    ];
  }

  /**
   * Returns CURL options common to most HTTP requests made here.
   *
   * These options do the following:
   * - Set the user agent.
   * - Request that content be returned.
   * - Disable returning the header.
   * - Enable redirect following.
   * - Set timeouts.
   *
   * If $includeAuthentication is TRUE, then HTTP basic user name and
   * password credentials are added to the header, if they have been set.
   *
   * @param bool $includeAuthentication
   *   (optional, default = TRUE) When TRUE, authentication credentials
   *   are included.
   *
   * @return array
   *   Returns an array of common Curl options.
   *
   * @see ::login()
   */
  protected function getCommonCurlOptions(bool $includeAuthentication = TRUE) {
    $options = [
      // Requests come from this class.
      CURLOPT_USERAGENT      => 'FolderShareConnect',

      // Return the request's results.
      CURLOPT_RETURNTRANSFER => TRUE,

      // Don't include the HTTP header in the results. This corrupts
      // those results. Instead, if the header is needed, a header callback
      // is used.
      CURLOPT_HEADER         => FALSE,

      // Don't encode.
      CURLOPT_ENCODING       => '',

      // Follow redirects.
      CURLOPT_FOLLOWLOCATION => TRUE,
      CURLOPT_AUTOREFERER    => TRUE,
      CURLOPT_MAXREDIRS      => 10,

      // Time-out if things stall.
      CURLOPT_CONNECTTIMEOUT => 120,
      CURLOPT_TIMEOUT        => 120,
    ];

    // If there is a need to include authentication credentials, add the
    // right options.
    if ($includeAuthentication === TRUE) {
      $this->printVerbose("  Using " .
        $this->getAuthenticationTypeName($this->authenticationType));

      switch ($this->authenticationType) {
        case self::AUTHENTICATION_BASIC:
          // Add credentials for basic authentication.
          $options[CURLOPT_HTTPAUTH] = CURLAUTH_BASIC;
          $options[CURLOPT_USERPWD] = $this->userName . ':' . $this->password;
          break;

        case self::AUTHENTICATION_COOKIE:
          // Add credentials for cookie authentication.
          $options[CURLOPT_COOKIEJAR] = "";
          $options[CURLOPT_COOKIEFILE] = "";
          break;
      }
    }

    return $options;
  }

  /*--------------------------------------------------------------------
   *
   * Server verification.
   *
   * These methods verify a connection to a server and request the
   * features it supports.
   *
   *--------------------------------------------------------------------*/

  /**
   * Resets verification of server communications.
   *
   * Server verification is needed prior to the first server request to
   * insure that the server exists and can respond to requests, and to
   * get the list of HTTP verbs supported by the sever.
   *
   * Server verification should be reset each time key communications
   * parameters are changed, such as the host name. It is not necessary to
   * reset on changes to authentication credentials since the server would
   * still exist and still support the same range of HTTP requests.
   *
   * @see ::verifyServer()
   */
  protected function unverifyServer() {
    // Log the user out if they are logged in.
    $this->logout();

    $this->serverVerified = FALSE;
    $this->httpVerbs = [];
  }

  /**
   * Verifies that the server exists and can respond to requests.
   *
   * This method is called the first time a request is made of the server.
   * It serves two purposes:
   * - Validates that the server exists and can respond.
   * - Gets the HTTP verbs that it responds to.
   *
   * An exception is thrown if the server does not exist or cannot respond.
   * An exception is also thrown if the server does not respond with an
   * 'Allow' header that lists supported HTTP verbs.
   *
   * Otherwise the 'Allow' header is used to initialize the $httpVerbs
   * field that lists supported HTTP verbs, such as 'GET', 'POST',
   * 'PATCH', and 'DELETE'.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   *
   * @see ::unverifyServer()
   */
  protected function verifyServer() {
    //
    // Validate
    // --------
    // If the server has already been verified, no further action is needed.
    if ($this->serverVerified === TRUE) {
      return;
    }

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    // Authentication credentials are not required.
    //
    // Use an OPTIONS request. The request should not return a body
    // and we need the header.
    //
    // Setting COOKIELIST to "ALL" clears all prior cookies.
    $url = $this->hostName . self::URL_GET . '/0?_format=json';

    $options                         = $this->getCommonCurlOptions(FALSE);
    $options[CURLOPT_URL]            = $url;
    $options[CURLOPT_HTTPGET]        = FALSE;
    $options[CURLOPT_CUSTOMREQUEST]  = 'OPTIONS';
    $options[CURLOPT_NOBODY]         = TRUE;
    $options[CURLOPT_HEADERFUNCTION] = [$this, 'verifyHeaderCallback'];
    $options[CURLOPT_COOKIELIST]     = "ALL";

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue request
    // -------------
    // There are two types of errors possible:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content will be the HTTP header.
    $this->printVerbose("Verifying server connection");

    $this->httpVerbs = [];

    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with CURL or with
      // its communications with the server. This is fatal.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    if ($httpCode !== 200) {
      // Server error. The server has rejected the request for any number
      // of reasons.
      if (isset($content['message']) === TRUE) {
        $message = $content['message'];
      }
      else {
        // Unfortunately, Drupal has not provided a meaningful HTTP code or
        // message on some failures. For instance, if the route we tried is not
        // recognized because the FolderShare module is not enabled, Drupal
        // returns a generic "404" error, indicating "The requested information
        // could not be found." This is no help to the user.
        if ($httpCode === 404) {
          $message = "The host has declined the connection.
This can occur if the host does not have the FolderShare module enabled,
or if web services for the module have not been enabled. Please contact the
host's administrator.";
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }
      }

      $this->printVerbose("  Server failed with HTTP code $httpCode");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    $this->printVerbose("  Server connection verified");
    $this->serverVerified = TRUE;
  }

  /**
   * Responds to an HTTP header receipt during a server verify.
   *
   * This method is called by CURL while verifying a connection. Each call
   * passes a line from the incoming HTTP header. The line is parsed
   * to look for "Allow", which includes the names of HTTP verbs supported.
   * This is saved for later use.
   *
   * @param resource $curlSession
   *   The resource for the current CURL session.
   * @param string $line
   *   The HTTP header line to parse.
   *
   * @return int
   *   Returns the number of bytes in the incoming HTTP header line.
   */
  private function verifyHeaderCallback($curlSession, $line) {
    // Get the length (in bytes) of the incoming line. This must be
    // returned when the function is done.
    $lineBytes = strlen($line);

    // Split the line to get the header key and value.
    $parts = mb_split(':', $line, 2);
    if (count($parts) !== 2) {
      return $lineBytes;
    }

    // We only want the allow header line.
    if ($parts[0] !== 'Allow') {
      return $lineBytes;
    }

    // Extract the HTTP verbs from the line.
    $verbs = explode(",", $parts[1]);
    foreach ($verbs as $verb) {
      $this->httpVerbs[] = strtoupper(trim($verb));
    }

    return $lineBytes;
  }

  /**
   * Returns TRUE if HTTP DELETE requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP DELETE requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpDeleteSupported() {
    $this->verifyServer();
    return in_array('DELETE', $this->httpVerbs);
  }

  /**
   * Returns TRUE if HTTP GET requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP GET requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpGetSupported() {
    $this->verifyServer();
    return in_array('GET', $this->httpVerbs);
  }

  /**
   * Returns TRUE if HTTP PATCH requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP PATCH requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpPatchSupported() {
    $this->verifyServer();
    return in_array('PATCH', $this->httpVerbs);
  }

  /**
   * Returns TRUE if HTTP POST requests are supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported.
   *
   * @return bool
   *   Returns TRUE if HTTP POST requests are supported.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   */
  public function isHttpPostSupported() {
    $this->verifyServer();
    return in_array('POST', $this->httpVerbs);
  }

  /**
   * Gets a list of HTTP operations supported on the server.
   *
   * If no requests have been made to the server yet, this method makes
   * a server request to get the list of HTTP requests supported. Typically
   * these include:
   * - GET = get items or configuration information.
   * - POST = create or upload new items.
   * - PATCH = change existing items.
   * - DELETE = delete existing items.
   *
   * A host usually has all of these enabled, but for security reasons it
   * is possible for a host to disable some or all of them. For instance,
   * a host that publishes public content may have GET enabled, but it
   * may disable POST, PATCH, and DELETE so that that content cannot be
   * modified.
   *
   * @return string[]
   *   Returns an array listing the HTTP verbs supported by the server.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact.
   *   - The host does not support the operation.
   *
   * @see ::getConfiguration()
   * @see ::isHttpDeleteSupported()
   * @see ::isHttpGetSupported()
   * @see ::isHttpPatchSupported()
   * @see ::isHttpPostSupported()
   */
  public function getHttpVerbs() {
    $this->verifyServer();
    return $this->httpVerbs;
  }

  /*--------------------------------------------------------------------
   *
   * CSRF token handling.
   *
   * A CSRF (Cross-Site Request Forgery) token must be requested, returned,
   * and used for all operations that might change remote content (e.g.
   * for POST, PATCH, and DELETE requests).
   *
   *--------------------------------------------------------------------*/

  /**
   * Clears the CSRF token saved from a prior request.
   *
   * The connection's CSRF token is initially cleared and it must be
   * cleared again (to trigger a future request for a new CSRF token)
   * any time primary communications parameters are changed, such as
   * the host name. Logging out also clears the CSRF token.
   *
   * @see ::getCSRFToken()
   * @see ::logout()
   */
  protected function clearCSRFToken() {
    $this->csrfToken = NULL;
  }

  /**
   * Returns the current CSRF token.
   *
   * A "Cross-Site Request Forgery" (CSRF) is a web site or user attack
   * that sends a message to a server, without the user's knowledge, to
   * change the user's data on the server. The message reuses the current
   * authentication credentials of a logged in user.
   *
   * A CSRF token is a randomly generated string created by the server and
   * issued to the client for use throughout a session. Drupal requires
   * that all "non-safe" HTTP requests (i.e. anything except OPTIONS, GET,
   * and HEAD) send a previously acquired CSRF token as part of its
   * validation mechanism. Requests without the CSRF token, or with a wrong
   * token, are rejected.
   *
   * The communications methods in this class call this method to get the
   * current CSRF token each time they need to make a "non-safe" operation.
   * If no token has been requested from the site yet, a request is made
   * immediately to get a new CSRF token. That token is saved and re-used
   * on future calls.
   *
   * Cookie-based authentication automatically retreives the CSRF token
   * during login. Other authentication types may require an explicit
   * request to get a CSRF token.
   *
   * @return string
   *   Returns the current CSRF token, or NULL if a token could not
   *   be retrieved because the site is down or it does not respond to
   *   a token request.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *
   * @see ::clearCSRFToken()
   * @see ::login()
   */
  protected function getCSRFToken() {
    //
    // Return current token (if any)
    // -----------------------------
    // If a previous request for a CSRF token has already returned one
    // for this session, return it immediately.
    if ($this->csrfToken !== NULL) {
      return $this->csrfToken;
    }

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication credentials are not required. In fact, if they are
    // included, the request will fail.
    $options = $this->getCommonCurlOptions(FALSE);
    $options[CURLOPT_HTTPGET] = TRUE;
    $options[CURLOPT_URL] = $this->hostName . self::URL_CSRF_TOKEN;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ---------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content is the CSRF token string.
    $this->printVerbose("Getting CSRF token");
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    if ($httpCode !== 200) {
      // A CSRF token was not returned! Operations that require the token
      // cannot be done.
      if (isset($content['message']) === TRUE) {
        $message = $content['message'];
      }
      else {
        $message = $this->getNiceHttpErrorMessage($httpCode);
      }

      $this->printVerbose("  Server failed with HTTP code $httpCode");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    $this->printVerbose("  CSRF token received");
    $this->csrfToken = $content;
    return $this->csrfToken;
  }

  /*--------------------------------------------------------------------
   *
   * Login and logout.
   *
   * Login uses the authentication type and credentials to establish an
   * authenticated connection with the server. Logout reverses that.
   *
   *--------------------------------------------------------------------*/

  /**
   * Logs the user in to the server using the given authentication credentials.
   *
   * Authentication credentials include a user name and password for
   * the remote server. Setting these credentials and logging in must be
   * done before any requests may be sent to the server.
   *
   * The way authentication credentials are used depends upon the
   * authentication type:
   * - AUTHENTICATION_NONE does not use the credentials at all. Requests
   *   to the server are not authenticated, which usually means the caller
   *   only has access to public content that is available to anonymous
   *   visitors to the site.
   * - AUTHENTICATION_BASIC sends the credentials along on every request.
   *   The server checks the credentials before responding.
   * - AUTHENTICATION_COOKIE sends the credentials along on an initial
   *   "login" request during which the server checks the credentials before
   *   responding with a session cookie. The session cookie is then sent
   *   along on all subsequent requests.
   *
   * AUTHENTICATION_NONE is the initial state for a newly opened connection
   * object, but it is rarely suitable for use. Most activities require an
   * authenticated connection.
   *
   * AUTHENTICATION_COOKIE is the style used by web browsers where the user
   * logs into a site, then makes requests for site pages. The browser saves
   * the session cookie and automatically re-uses it for each request.
   *
   * AUTHENTICATION_BASIC is the style used by many web services. The
   * credentials are passed along with every request and there are no cookies
   * involved. This works because web services are often isolated requests
   * rather than a user asking for page after page after page.
   *
   * The AUTHENTICATION_COOKIE type is the most efficient when multiple
   * requests are made through the same open connection. This type only does
   * full authentication on the server at the start of a series of requests.
   * However, if the server has a non-standard login process, then this
   * class cannot reliably get the session cookie and authentication will
   * fail.
   *
   * The AUTHENTICATION_BASIC type is the most reliable since it can work
   * regardless of the login process.
   *
   * The special AUTHENTICATION_AUTO type indicates that automatic type
   * finding should progress through several authentication types and stop
   * on the first one that succeeds.
   *
   * Authentication failure can occur for several reasons:
   * - The server may not support web services at all.
   * - The server may have a non-standard user login form that requires a
   *   CAPTCHA or other required input that this software cannot provide.
   * - The server may not have the authentication type enabled.
   * - The server may reject the user name and password as invalid.
   *
   * If the user name is empty, no authentication can be done and the
   * authentication type is automatically reset to AUTHENTICATION_NONE.
   *
   * @param string $userName
   *   The user name. If the name is empty, authentication is disabled and
   *   the authentication type is set to AUTHENTICATION_NONE.
   * @param string $password
   *   The password. An empty password is allowed, but discouraged.
   * @param int $authenticationType
   *   (optional, default = AUTHENTICATION_AUTO) The type of
   *   authentication to use with the credentials.
   *
   * @return bool
   *   Returns TRUE if the login is successful, and FALSE otherwise.
   *   Failed authentication often throws an exception.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host refuses contact.
   *   - The authentication type is not accepted.
   *   - The user name or password are not accepted.
   *
   * @see ::getUserName()
   * @see ::getPassword()
   * @see ::getAuthenticationType()
   * @see ::isLoggedIn()
   * @see ::logout()
   */
  public function login(
    string $userName,
    string $password,
    int $authenticationType = self::AUTHENTICATION_AUTO) {

    //
    // Verify server
    // -------------
    // If the server connection has not yet been verified, do so now.
    // We cannot log in without being sure that the host and port are
    // right and that a server is responding.
    //
    // This call returns immediately if the server is already verified.
    //
    // This call throws an exception if the host name is bad or there
    // is some other problem communicating with the server.
    $this->verifyServer();

    //
    // Log out
    // -------
    // If the user is already logged in, then log out first. After this,
    // the authentication status is guaranteed to be STATUS_NOT_LOGGED_IN.
    //
    // This call returns immediately if the user is not logged in.
    $this->logout();

    //
    // Save values
    // -----------
    // If the user name is empty, then there is no authentication type.
    // Otherwise, select the indicated authentication type and save the
    // user name and password.
    if (empty($userName) === TRUE) {
      $authenticationType = self::AUTHENTICATION_NONE;
      $this->userName = '';
      $this->password = '';
    }
    else {
      $this->userName = $userName;
      $this->password = $password;
    }

    //
    // Log in
    // ------
    // Use the given authentication type. If it is for automatic type
    // finding, then this will loop through several methods to find the
    // first one that works.
    return $this->loginInternal($authenticationType);
  }

  /**
   * Logs the user in, recursing through more than one method.
   *
   * The requested authentication type is used to log the user in and
   * confirm that it worked. If the AUTHENTICATION_AUTO type is used,
   * and the initial login or validation fails, then the next type is
   * tried by recursing.
   *
   * @param int $authenticationType
   *   The type of authentication to use with current credentials.
   * @param int $autoIndex
   *   (optional, default = 0) If the authentication type is
   *   AUTHENTICATION_AUTO, the $autoIndex indicates the next authentication
   *   type to try. For other authentication types, the index is not used.
   *
   * @return bool
   *   Returns TRUE if the login is successful, and FALSE on failure.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host refuses contact.
   *   - The user name or password are not accepted.
   *
   * @see ::login()
   */
  private function loginInternal(int $authenticationType, int $autoIndex = 0) {

    //
    // Select authentication type
    // --------------------------
    // If an explicit authentication type has been requested, use it.
    // Otherwise for automatic type finding, try the next one.
    if ($authenticationType === self::AUTHENTICATION_AUTO) {
      if ($autoIndex < 0 ||
          $autoIndex >= count(self::AUTHENTICATION_AUTO_ORDER)) {
        // The auto index is out of bounds. We've reached the end of
        // automatic authentication type handling.
        $this->authenticationType = self::AUTHENTICATION_NONE;
        throw new \RuntimeException(
"The login to the host failed.
The user name and/or password may be incorrect. Please check them for typos.
If they appear correct, it is also possible that the host's web services are
not configured to support the type of authentication used by this software.
Please contact the host's administrator.");
      }
      else {
        // Try the next authentication type.
        $this->authenticationType = self::AUTHENTICATION_AUTO_ORDER[$autoIndex];
        $auto = TRUE;
      }
    }
    else {
      // Use the explicit authentication type requested.
      $this->authenticationType = $authenticationType;
      $auto = FALSE;
    }

    //
    // Log in
    // ------
    // Based upon the authentication type, contact the server.
    $this->printVerbose("  Logging in with " .
      $this->getAuthenticationTypeName($this->authenticationType));

    $savedException = NULL;

    switch ($this->authenticationType) {
      default:
      case self::AUTHENTICATION_NONE:
        // No authentication.
        //
        // When there is no authentication in use, the user is always
        // logged out and only has access to public content available for
        // non-authenticated users.
        $this->authenticationStatus = self::STATUS_NOT_LOGGED_IN;
        return FALSE;

      case self::AUTHENTICATION_BASIC:
        // Authentication is on every request.
        //
        // When using basic authentication, the user is logged in separately
        // on every request. There is no explicit login process. The status
        // is set to pending until the first request using the credentials
        // confirms that the credentials work.
        $this->authenticationStatus = self::STATUS_PENDING;
        break;

      case self::AUTHENTICATION_COOKIE:
        // Authentication uses a session cookie.
        //
        // When using cookie authentication, the user is logged in by sending
        // credentials now. On success, the server returns a session cookie
        // that is used for further requests.
        try {
          $this->loginForCookie();
          $this->authenticationStatus = self::STATUS_PENDING;
          $this->printVerbose("  Authentication succeeded");
        }
        catch (\Exception $e) {
          $this->authenticationStatus = self::STATUS_FAILED;
          $this->printVerbose("  Authentication failed");
          $savedException = $e;
        }
        break;
    }

    // If authentication failed, either stop or advance to the next
    // automatic authentication type check.
    if ($this->authenticationStatus === self::STATUS_FAILED) {
      if ($auto === FALSE) {
        if ($savedException !== NULL) {
          throw $savedException;
        }
        return FALSE;
      }

      return $this->loginInternal(self::AUTHENTICATION_AUTO, ($autoIndex + 1));
    }

    //
    // Test login
    // ----------
    // The above login may have succeeded, but the mechanism for loggin in
    // *DOES NOT* guarantee further access to content. The Drupal REST
    // module can be configured by a site to only support a specific
    // authentication type (e.g. cookies or basic). This means it is
    // possible to log in with cookies, then fail when a REST request is made.
    //
    // We'd like to detect this problem and switch authentication methods
    // if needed. To do so, we need to issue a request and see if it fails.
    try {
      // Make a gratuitous request for the site's configuration. The server
      // always returns success on this request IF the site's REST configuration
      // supports the current authentication type.
      $this->printVerbose("  Testing authentication");
      $this->getConfiguration();
      $this->printVerbose("  Testing succeeded");
    }
    catch (\Exception $e) {
      // The request failed!
      $this->authenticationStatus = self::STATUS_FAILED;
      $this->printVerbose("  Testing failed");

      // If the test failed with any error except 403, then the site
      // configuration is not compatible with this class. We have to fail,
      // even when using automatic authentication type finding.
      $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
      if ($httpCode !== 403) {
        // It wasn't a 403 error.
        //
        // Log out in order to clean up state (this may try to send another
        // request, but it won't throw an exception).
        //
        // Error codes and messages from testing are not useful to return
        // to the caller. For example, if the web service is not enabled,
        // testing will return a 404 error and a complaint that the route
        // is bad. That is not a useful message for the user.
        //
        // Instead, re-throw an earlier exception, or throw a new exception
        // with a useful message.
        $this->logout();
        if ($savedException !== NULL) {
          throw $savedException;
        }
        throw new \RuntimeException(
"The login to the host failed.
The host is not responding properly to communications requests. This can
occur if the host's web services are not enabled. Please contact the host's
administrator.");
      }

      // When the error code is 403, the server is telling us that it is
      // not configured to use the authentication method or serialization
      // format we tried, even though it succeeded with the login. This can
      // happen if we've used cookie authentication to log in, but the REST
      // services we need to use have been set for basic authentication,
      // or something else. This can also happen if we've sent JSON format
      // data, but the server is not configured to accept it.
      //
      // If we're not using automatic authentication type finding, then
      // we're done and have to fail.
      if ($auto === FALSE) {
        // Log out in order to clean up state (this may try to send another
        // request, but it won't throw an exception).
        $this->logout();
        throw new \RuntimeException(
"The login to the host failed.
The host is not configured to accept the type of communications done by
this software. This may be due to a configuration problem with the host's
web services. Please contact the host's administrator.");
      }

      // Try the next authentication type.
      return $this->loginInternal(self::AUTHENTICATION_AUTO, ($autoIndex + 1));
    }

    // The login test succeeded! We're logged in with an authentication
    // method that the site supports.
    $this->authenticationStatus = self::STATUS_LOGGED_IN;
    return TRUE;
  }

  /**
   * Logs in using cookie authentication.
   *
   * The current credentials are used to log in and request a session
   * cookie, which is automatically saved for further use within CURL.
   * A successful login also returns and saves the CSRF token and a
   * logout token.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host does not support the operation.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   *
   * @see ::login()
   */
  private function loginForCookie() {
    //
    // Create headers
    // --------------
    // The headers specify that post fields are in JSON format.
    $headers = [];
    $headers[] = 'Content-Type: application/json';

    $postFields = [
      'name' => $this->userName,
      'pass' => $this->password,
    ];

    $postText = json_encode($postFields);

    //
    // Create URL
    // ----------
    // The POST URL includes:
    // - The host name.
    // - The post web services path.
    // - The return syntax.
    $url = $this->hostName . self::URL_USER_LOGIN . '?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Setting COOKIELIST to "ALL" clears all prior cookies.
    //
    // Setting COOKIEFILE to "" causes CURL to maintain cookies in memory
    // instead of in a file.
    $options                     = $this->getCommonCurlOptions(FALSE);
    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_POST]       = 1;
    $options[CURLOPT_POSTFIELDS] = $postText;
    $options[CURLOPT_COOKIELIST] = "ALL";
    $options[CURLOPT_COOKIEFILE] = "";
    $options[CURLOPT_HTTPHEADER] = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    switch ($httpCode) {
      case 200:
        // OK. The request succeeded. Continue.
        break;

      case 400:
        // Drupal's UserAuthenticationController checks the incoming
        // credentials and responds with any of several possible errors.
        // Unfortunately, they all come back as a generic HTTP 400 error
        // for a "Bad request":
        // - Missing credentials.
        // - Missing credentials.name.
        // - Missing credentials.pass.
        // - User account has not been activated or is blocked.
        // - Sorry, unrecognized username or password.
        //
        // The first three are not possible because we created and passed
        // the POST fields above.
        //
        // The latter two errors are important and should have been 401 errors.
        if (isset($content['message']) === TRUE) {
          // Use the message returned by Drupal, as bad as it is.
          $message = $content['message'];
          if (mb_ereg_search('blocked', $message) === TRUE) {
            // Replace the message with something friendlier.
            $message = "The login to the host has failed.
The account may have been blocked. If the account is new, it may not yet have
been activated. Please contact the host's administrator.";
          }
          elseif (mb_ereg_search('unrecognized', $message) === TRUE) {
            $message = "The login to the host has failed.
The user name and/or password may be incorrect. Please check them for typos.";
          }
        }
        else {
          $message = "The login to the host has failed.
The user name and/or password may be incorrect. Please check them for typos.
If they appear correct, it is also possible that the account has been blocked.
If the account is new, it may not yet have been activated. Please contact the
host's administrator.";
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);

      case 429:
        // Drupal's UserAuthenticationController checks for rapid failed
        // login requests and, after a limit, blocks the account for the
        // requestor's IP address.
        //
        // Fall thru to the 'default' HTTP code handling.
        //
      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }

    //
    // Parse content
    // -------------
    // The returned content is an associative array of the form:
    // @code
    // [
    //   "current_user" => [
    //     "uid" => 1234,
    //     "roles" => [
    //       "authenticated",
    //       "administrator",
    //       ...
    //     ],
    //     "name" => "myname",
    //   ],
    //   "csrf_token" => "token",
    //   "logout_token" => "token",
    // ]
    // @endcode
    //
    // The "name" we already know since we provided it in the first place.
    // The user ID and roles are irrelevant here.
    //
    // Get and save the CSRF and logout tokens. The CSRF token must be
    // sent to the server on all requests that change content (i.e.
    // POST, PATCH, and DELETE). The logout token must sent to the server
    // to formally log out.
    if (isset($content['csrf_token']) === TRUE) {
      $this->csrfToken = $content['csrf_token'];
    }

    if (isset($content['logout_token']) === TRUE) {
      $this->logoutToken = $content['logout_token'];
    }
  }

  /**
   * Logs the user out of the server.
   *
   * If the user is not logged in, this method has no effect.
   *
   * If the user is logged in, they are logged out and their authentication
   * credentials cleared. Further requests to the server will not provide
   * authentication credentials. These requests may succeed if the server
   * allows unauthenticated access, but they will fail if the user needs
   * to be logged in.
   *
   * @see ::login()
   * @see ::isLoggedIn()
   */
  public function logout() {
    //
    // Logout
    // ------
    // If the server hasn't been verified yet, then we're already logged out.
    // If the user is logged in, log them out.
    if ($this->serverVerified === FALSE) {
      return;
    }

    if ($this->authenticationStatus === self::STATUS_LOGGED_IN ||
        $this->authenticationStatus === self::STATUS_PENDING) {
      switch ($this->authenticationType) {
        default:
        case self::AUTHENTICATION_NONE:
        case self::AUTHENTICATION_BASIC:
          // No logout required.
          break;

        case self::AUTHENTICATION_COOKIE:
          // Logout with the logout token.
          $this->printVerbose("Logging out");
          try {
            $this->logoutForCookie();
          }
          catch (\Exception $e) {
            // Ignore exceptions.
          }
          $this->printVerbose("  Logged out");
          break;
      }
    }

    //
    // Reset
    // -----
    // Clear the authentication status, authentication type, user name,
    // and password.
    $this->authenticationStatus = self::STATUS_NOT_LOGGED_IN;
    $this->authenticationType = self::AUTHENTICATION_NONE;
    $this->userName = '';
    $this->password = '';
    $this->logoutToken = '';
    $this->clearCSRFToken();
  }

  /**
   * Logs out using cookie authentication.
   *
   * The logout token, if any, is used to log out the user.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such as with a bad host name.
   *   - The host does not support the operation.
   *   - The host refuses contact, such as with bad authentication credentials.
   *
   * @see ::logout()
   */
  private function logoutForCookie() {
    //
    // Validate
    // --------
    // If there is no saved logout token from a prior login, then there
    // is no need to logout.
    if (empty($this->logoutToken) === TRUE) {
      return;
    }

    //
    // Create URL
    // ----------
    // The POST URL includes:
    // - The host name.
    // - The post logout path.
    // - The return syntax.
    // - The logout token.
    $url = $this->hostName . self::URL_USER_LOGOUT . '?_format=json';
    $url .= '&token=' . $this->logoutToken;

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    $options                     = $this->getCommonCurlOptions(FALSE);
    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_POST]       = 1;
    $options[CURLOPT_POSTFIELDS] = '';

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    //
    // A POST to log out should always succeed and not return anything.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
      case 204:
        return;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /*--------------------------------------------------------------------
   *
   * Issue requests.
   *
   * These methods issue HTTP requests for raw data or to trigger operations.
   * Other methods parse that data and return it.
   *
   *--------------------------------------------------------------------*/

  /**
   * Issues a GET request.
   *
   * GET requests are used to retrieve information from the server.  The
   * type of information varies with the operation choice:
   * - Single entity requests:
   *   - 'get-entity' returns an entity.
   *   - 'get-parent' returns an entity's parent entity.
   *   - 'get-root' returns an entity's root entity.
   * - Special entity information requests:
   *   - 'get-sharing' returns an entity's sharing settings.
   * - Entity list requests:
   *   - 'get-ancestors' returns a list of an entity's ancestor entities.
   *   - 'get-descendants' returns a list of an entity's descendant entities.
   *   - 'get-search' returns a search through an entity's subtree.
   * - Configuration and misc data requests:
   *   - 'get-configuration' returns site and module settings.
   *   - 'get-usage' returns module usage stats for the user.
   *   - 'get-version' returns version numbers for site software.
   *
   * GET requests focused on an entity (get the entity, parent, root,
   * ancestors, or descendants) require a full folder path or a numeric
   * entity ID to indicate the entity.
   *
   * @param string $operation
   *   The name of the requested operation (e.g. "get-entity").
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder.
   *   Some operations do not use this value.
   *
   * @return mixed
   *   Returns a variety of content types depending upon the operation.
   *   In most cases, the content returned is an array.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpGet(string $operation, $entityIdOrPath) {
    //
    // Initialize
    // ----------
    // Check if HTTP GET is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpGetSupported() === FALSE) {
      throw new \RuntimeException(
        "The operation cannot be completed.\nThe host does not support requests to get content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the GET operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Get-Operation: ' . $operation;

    // Request the returned data in a specific format.
    $headers[] = 'X-FolderShare-Return-Format: ' . $this->format;

    // Set the source path if an entity ID is not used.
    if (is_numeric($entityIdOrPath) === TRUE) {
      $entityId = intval($entityIdOrPath);
    }
    else {
      // Make sure the path is safe. HTTP headers primarily support ASCII,
      // while paths may include multi-byte characters. Use URL encoding
      // to add them to the header.
      $entityId = 0;
      $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($entityIdOrPath);
    }

    //
    // Create URL
    // ----------
    // The GET URL includes:
    // - The host name.
    // - The canonical web services path.
    // - The entity ID (even if one is not used).
    // - The return syntax.
    $url = $this->hostName . self::URL_GET . '/' . $entityId . '?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is not required.
    $this->printVerbose("Issuing GET for $operation");
    $options                     = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]        = $url;
    $options[CURLOPT_HTTPGET]    = TRUE;
    $options[CURLOPT_HTTPHEADER] = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ---------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A 200 is returned when there is content, and 204 when there isn't.
    // Both are OK.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
        $this->printVerbose("  Request complete");
        return $content;

      case 204:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /**
   * Deletes content on a web server.
   *
   * DELETE requests are used to delete a single entity, or a subtree,
   * based upon the operation choice:
   * - 'delete-file' deletes a single file.
   * - 'delete-folder' deletes a single empty folder.
   * - 'delete-folder-tree' deletes a single folder recursively.
   * - 'delete-file-or-folder' deletes a single file or empty folder.
   * - 'delete-file-or-folder-tree' deletes anything recursively.
   *
   * DELETE requests require a full folder path or a numeric entity ID
   * to indicate the entity to delete.
   *
   * DELETE requests do not return content. On an error, an exception
   * is thrown.
   *
   * @param string $operation
   *   The name of the requested operation (e.g. "delete-file").
   * @param int|string $entityIdOrPath
   *   Some operations do not use this value.
   *   The numeric entity ID or string path for a remote file or folder.
   *
   * @return mixed
   *   Always empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpDelete(string $operation, $entityIdOrPath) {
    //
    // Initialize
    // ----------
    // Check if HTTP DELETE is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpDeleteSupported() === FALSE) {
      throw new \RuntimeException(
        "The operation cannot be completed.\nThe host does not support requests to delete content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the DELETE operation and the source path.
    // There is no return format header because DELETE never returns
    // anything except success or error codes.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Delete-Operation: ' . $operation;

    // Get the CSRF token. This may trigger a GET request to the server.
    // If that fails, an exception is thrown.
    $headers[] = 'X-CSRF-Token: ' . $this->getCSRFToken();

    // Set the source path if an entity ID is not used.
    if (is_numeric($entityIdOrPath) === TRUE) {
      $entityId = intval($entityIdOrPath);
    }
    else {
      // Make sure the path is safe. HTTP headers primarily support ASCII,
      // while paths may include multi-byte characters. Use URL encoding
      // to add them to the header.
      $entityId = 0;
      $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($entityIdOrPath);
    }

    //
    // Create URL
    // ----------
    // The DELETE URL includes:
    // - The host name.
    // - The canonical web services path.
    // - The entity ID (even if one is not used).
    // - The return syntax.
    $url = $this->hostName . self::URL_DELETE . '/' . $entityId . '?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is required.
    $this->printVerbose("Issuing DELETE for $operation");
    $options                        = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]           = $url;
    $options[CURLOPT_CUSTOMREQUEST] = 'DELETE';
    $options[CURLOPT_HTTPHEADER]    = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue DELETE
    // ------------
    // Issue an HTTP DELETE to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // Since a DELETE never returns anything, only a 204 is valid.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 204:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /**
   * Posts new content to the web server.
   *
   * POST requests are used to create a single entity based upon the
   * operation choice:
   * - 'new-rootfolder' creates a new root folder.
   * - 'new-folder' creates a new subfolder.
   * - 'new-file' creates a new file.
   * - 'new-media' creates a new media item.
   *
   * POST requests never support a numeric entity ID since the operation
   * is creating an entity. The $path argument selects the location in
   * which to create the new entity.
   *
   * @param string $operation
   *   The name of the requested operation.
   * @param string $path
   *   The path to a remote parent folder into which to place a new entity.
   * @param array $postFields
   *   (optional, default = []) The post fields in 'full' entity format
   *   for operations that need additional values.
   *
   * @return mixed
   *   Returns a variety of content types depending upon the operation.
   *   In most cases, the content returned is an array.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpPost(
    string $operation,
    string $path,
    array $postFields = []) {

    //
    // Initialize
    // ----------
    // Check if HTTP POST is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpPostSupported() === FALSE) {
      throw new \RuntimeException(
        "The operation cannot be completed.\nThe host does not support requests to create or upload new content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the POST operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Post-Operation: ' . $operation;

    // Get the CSRF token. This may trigger a GET request to the server.
    // If that fails, an exception is thrown.
    $headers[] = 'X-CSRF-Token: ' . $this->getCSRFToken();

    // Make sure the path is safe. HTTP headers primarily support ASCII,
    // while paths may include multi-byte characters. Use URL encoding
    // to add them to the header.
    $headers[] = 'X-FolderShare-Destination-Path: ' . rawurlencode($path);

    // POST fields are serialized as JSON.
    $headers[] = 'Content-Type: application/json';

    // Request the returned data in a specific format.
    $headers[] = 'X-FolderShare-Return-Format: ' . $this->format;

    // Process post fields, if provided.
    if (empty($postFields) === TRUE) {
      $postFields = $this->createDummyEntity();
    }

    $postText = json_encode($postFields);

    //
    // Create URL
    // ----------
    // The POST URL includes:
    // - The host name.
    // - The post web services path.
    // - The return syntax.
    $url = $this->hostName . self::URL_POST . '?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is required.
    $this->printVerbose("Issuing POST for $operation");
    $options                      = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]         = $url;
    $options[CURLOPT_POST]        = 1;
    $options[CURLOPT_SAFE_UPLOAD] = TRUE;
    $options[CURLOPT_POSTFIELDS]  = $postText;
    $options[CURLOPT_HTTPHEADER]  = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A POST always creates content, so all successful requests return 201.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 201:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /**
   * Updates content on the web server.
   *
   * PATCH requests are used to update a single entity based upon the
   * operation choice:
   * - 'update-entity' changes one or more entity fields.
   * - 'update-sharing' changes an entity's sharing settings.
   * - 'move-overwrite' moves/renames an entity, optionally overwriting.
   * - 'move-no-overwrite' moves/renames an entity without overwriting.
   *
   * PATCH requests require a full folder path or a numeric entity ID
   * to indicate the entity to delete.
   *
   * @param string $operation
   *   The name of the requested operation.
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder.
   * @param string $destinationPath
   *   (optional, default = "") The string path for the remote destination
   *   on move and copy operations. Other operations do not use this value.
   * @param array $postFields
   *   (optional, default = []) The post fields in 'full' entity format
   *   for operations that need additional values.
   *
   * @return mixed
   *   Returns a variety of content types depending upon the operation.
   *   In most cases, the content returned is an array.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The arguments are malformed.
   *   - The arguments are invalid, such as for non-existent items.
   */
  protected function httpPatch(
    string $operation,
    string $entityIdOrPath,
    string $destinationPath,
    array $postFields = []) {

    //
    // Initialize
    // ----------
    // Check if HTTP POST is supported. This may issue a connection to the
    // server to find out. If that fails, an exception is thrown.
    if ($this->isHttpPostSupported() === FALSE) {
      throw new \RuntimeException(
        "The operation cannot be completed.\nThe host does not support requests to create or upload new content.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the POST operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Patch-Operation: ' . $operation;

    // Get the CSRF token. This may trigger a GET request to the server.
    // If that fails, an exception is thrown.
    $headers[] = 'X-CSRF-Token: ' . $this->getCSRFToken();

    // Set the source path if an entity ID is not used.
    if (is_numeric($entityIdOrPath) === TRUE) {
      $entityId = intval($entityIdOrPath);
    }
    else {
      // Make sure the path is safe. HTTP headers primarily support ASCII,
      // while paths may include multi-byte characters. Use URL encoding
      // to add them to the header.
      $entityId = 0;
      $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($entityIdOrPath);
    }

    // Set the destination path, if any.
    if (empty($destinationPath) === FALSE) {
      $headers[] = 'X-FolderShare-Destination-Path: ' . rawurlencode($destinationPath);
    }

    // POST fields are serialized as JSON.
    $headers[] = 'Content-Type: application/json';

    // Request the returned data in a specific format.
    $headers[] = 'X-FolderShare-Return-Format: ' . $this->format;

    // Process post fields, if provided.
    if (empty($postFields) === TRUE) {
      $postFields = $this->createDummyEntity();
    }

    $postText = json_encode($postFields);

    //
    // Create URL
    // ----------
    // The PATCH URL includes:
    // - The host name.
    // - The canonical web services path.
    // - The entity ID (even if one is not used).
    // - The return syntax.
    $url = $this->hostName . self::URL_PATCH . '/' . $entityId . '?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included for most operations.
    //
    // A CSRF token is required.
    $this->printVerbose("Issuing PATCH for $operation");
    $options                        = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]           = $url;
    $options[CURLOPT_CUSTOMREQUEST] = 'PATCH';
    $options[CURLOPT_SAFE_UPLOAD]   = TRUE;
    $options[CURLOPT_POSTFIELDS]    = $postText;
    $options[CURLOPT_HTTPHEADER]    = $headers;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue PATCH
    // -----------
    // Issue an HTTP PATCH to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A PATCH may modify or create content, so 200 and 201 are acceptable.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
        $this->printVerbose("  Request complete");
        return $content;

      case 201:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

  /*--------------------------------------------------------------------
   *
   * GET requests.
   *
   * These methods issue low-level HTTP GET requests and return
   * appropriate structured content.
   *
   *--------------------------------------------------------------------*/

  /**
   * Gets information about a file or folder.
   *
   * An array is returned that describes the item.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root folder IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder.
   *
   * @return array
   *   Returns an array of information describing the file or folder.
   *   The format of the information depends upon the current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   */
  public function getFileOrFolder($entityIdOrPath) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-entity", $entityIdOrPath);
  }

  /**
   * Gets information about a file or folder's parent folder.
   *
   * An array is returned that describes the item's parent folder.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root folder IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome parent folder information is returned.
   *
   * @return array
   *   Returns an array of information describing the file or folder's
   *   parent folder. The format of the information depends upon the
   *   current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   * @see ::getRootFolder()
   */
  public function getParentFolder($entityIdOrPath) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-parent", $entityIdOrPath);
  }

  /**
   * Gets information about a file or folder's top-level (root) folder.
   *
   * An array is returned that describes the item's top-level (root) folder.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root folder IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome root folder information is returned.
   *
   * @return array
   *   Returns an array of information describing the file or folder's
   *   root folder. The format of the information depends upon the
   *   current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   * @see ::getParentFolder()
   * @see ::getRootFolders()
   */
  public function getRootFolder($entityIdOrPath) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-root", $entityIdOrPath);
  }

  /**
   * Gets a list of ancestor folders for a file or folder.
   *
   * An array is returned that contains a list of ancestors, ordered from
   * the top-level folder down to (but not including) the indicated item.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root folder IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome ancestor information is returned.
   *
   * @return array
   *   Returns an array of information describing a list of the file or
   *   folder's ancestors. The format of the information depends upon
   *   the current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   */
  public function getAncestors($entityIdOrPath) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-ancestors", $entityIdOrPath);
  }

  /**
   * Gets a list of descendant (child) files and folders for a folder.
   *
   * An array is returned that contains a list of descendants, if any.
   * If the item is a file, there are no descendants.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root folder IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder
   *   for whome descendant (child) folder information is returned.
   *
   * @return array
   *   Returns an array of information describing a list of the item's
   *   descendants. The format of the information depends upon the current
   *   return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item does not exist.
   *   - The user does not have necessary permissions.
   *
   * @see ::download()
   */
  public function getDescendants($entityIdOrPath) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-descendants", $entityIdOrPath);
  }

  /**
   * Gets a list of top-level folders.
   *
   * An array is returned that contains a list of top-level folders in
   * the selected "scheme". Recognized schemes include:
   *   - 'private' returns the user's own top-level folders.
   *   - 'public' returns all publically accessible top-level folders.
   *   - 'shared' returns top-level folders shared explicitly with the user.
   *
   * The format of the returned content depends upon the currently selected
   * return format. The content includes mandatory fields for each item,
   * including its name, creation and modified dates, MIME type, kind,
   * entity ID, and parent and root folder IDs. The returned content may
   * include additional fields if they are not empty, including the item's
   * description, comments, etc.
   *
   * @param string $scheme
   *   (optional, default = 'private') The name of a well-known group of
   *   top-level folders.
   *
   * @return array
   *   Returns an array of information describing a list of root folders.
   *   The format of the information depends upon the current return format.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the scheme is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The root folder scheme is malformed.
   *   - The user's root folder list is locked by another process.
   *
   * @see ::download()
   * @see ::getRootFolder()
   */
  public function getRootFolders(string $scheme = 'private') {
    //
    // Validate
    // --------
    // The scheme cannot be empty. Further scheme checking is left to
    // the server.
    if (empty($scheme) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote top-level folder scheme.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-descendants", $scheme . ':/');
  }

  /**
   * Get a report on the user's FolderShare usage.
   *
   * An associative array is returned where keys and values indicate the
   * current user's level of usage of the FolderShare virtual file system
   * on the server. The following keys are expected:
   * - 'nRootFolders' = the number of root folders.
   * - 'nFolders' = the number of subfolders.
   * - 'nFiles' = the number of files.
   * - 'nBytes' = the amount of storage space used, in bytes.
   *
   * The returned array also includes the following keys:
   * - 'host' = the host name.
   * - 'user-id' = the numeric user ID of the authenticated user.
   * - 'user-account-name' = the text account name of the authenticated user.
   * - 'user-display-name' = the text display name of the authenticated user.
   *
   * There may be additional values, depending upon the site and the
   * software installed at the site.
   *
   * @return array
   *   Returns a key-value array describing the user's usage of the module.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   */
  public function getUsage() {
    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-usage", 0);
  }

  /**
   * Get a report on the server's software configuraiton.
   *
   * An associative array is returned where keys and values are for
   * server software parameters. The following keys are expected:
   *
   * - 'file-restrict-extensions' = TRUE or FALSE indicating if file name
   *   extension restrictions are enabled.
   *
   * - 'file-allowed-extensions' = a space-separated list of file name
   *   extensions checked, if extension restrictions are enabled.
   *
   * - 'file-maximum-upload-size' = the maximum size, in bytes, for each
   *   uploaded file.
   *
   * - 'file-maximum-upload-number' = the maximum number of files that can
   *   be uploaded in a single request.
   *
   * - 'sharing-allowed' = TRUE or FALSE indicating if folder sharing
   *   is enabled on the site.
   *
   * - 'sharing-allowed-with-anonymous' = TRUE or FALSE indicating if folder
   *   sharing with the "anonymous" user (the unauthenticated public) is
   *   enabled on the site.
   *
   * - 'serializer-formats' = a list of serialization formats configured
   *   for the method.
   *
   * - 'authentication-providers' = a list of authentication providers
   *   configured for the method.
   *
   * The returned array also includes the following keys:
   * - 'host' = the host name.
   *
   * There may be additional values, depending upon the site and the
   * software installed at the site.
   *
   * @return array
   *   Returns a key-value array of values describing the site and module
   *   configuration.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *
   * @see ::getHttpVerbs()
   * @see ::getVersion()
   */
  public function getConfiguration() {
    //
    // Execute
    // -------
    // Issue the request.
    return $this->httpGet("get-configuration", 0);
  }

  /**
   * Get a report on software version numbers.
   *
   * An associative array is returned where keys are software items and
   * values are associative arrays that each have two keys and values:
   * - 'name' = the human-readable name of the item.
   * - 'version' = the version number of the item.
   *
   * If $doConnect is FALSE, the returned array only describes the client
   * side software. Otherwise a connection to the server is made and the
   * returned array describes both the client side and server side software.
   *
   * When a connection is made, the returned array also includes the
   * following keys:
   * - 'host' = the host name.
   *
   * @param bool $doConnect
   *   (optional, default = TRUE) When TRUE, the returned array includes
   *   client and server information. When FALSE, the array only includes
   *   client information and no communications with the server is done.
   *
   * @return array
   *   Returns a key-value array of software items and their names and
   *   version numbers.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *
   * @see ::getConfiguration()
   */
  public function getVersion(bool $doConnect = TRUE) {
    //
    // Create API versions
    // -------------------
    // For non-connecting requests, the API's information is all that is
    // returned. For connecting requests, the API's information is prepended
    // to whatever the server returns.
    $curlVersion = curl_version();

    $clientVersions = [
      'client' => [
        'foldershareconnect' => [
          'name'    => 'FolderShareConnect client API',
          'version' => self::VERSION,
        ],
        'clientphp' => [
          'name'    => 'PHP',
          'version' => phpversion(),
        ],
        'curl'      => [
          'name'    => 'cURL library',
          'version' => $curlVersion['version'],
        ],
        'ssl'       => [
          'name'    => 'OpenSSL library',
          'version' => $curlVersion['ssl_version'],
        ],
        'libz'       => [
          'name'    => 'Z compression library',
          'version' => $curlVersion['libz_version'],
        ],
      ],
    ];

    //
    // Execute
    // -------
    // Issue the request.
    if ($doConnect === FALSE) {
      return $clientVersions;
    }

    return array_merge($clientVersions, $this->httpGet("get-version", 0));
  }

  /*--------------------------------------------------------------------
   *
   * DELETE requests.
   *
   *--------------------------------------------------------------------*/

  /**
   * Deletes a file.
   *
   * This request will delete any type of file, including data files,
   * image files, or media items.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The item does not exist.
   *   - The item is not a file.
   *   - The item is locked by another process.
   *
   * @see ::deleteFileOrFolder()
   * @see ::deleteFolder()
   */
  public function deleteFile($entityIdOrPath) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpDelete("delete-file", $entityIdOrPath);
  }

  /**
   * Deletes a file or folder, optionally recursively.
   *
   * If the item indicated by the integer ID or path is a folder, and
   * $recurse is FALSE, the folder must be empty. If $recurse is TRUE,
   * non-empty folders will have their content deleted first, recursing
   * as necessary through subfolders.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote file or folder.
   * @param bool $recurse
   *   (optional, default = FALSE) When TRUE, non-empty folders are deleted
   *   recursively, including any subfolders and their content. When FALSE,
   *   the operation only deletes files or empty folders.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The item does not exist.
   *   - The item is locked by another process.
   *
   * @see ::deleteFile()
   * @see ::deleteFolder()
   */
  public function deleteFileOrFolder($entityIdOrPath, bool $recurse = FALSE) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($recurse === TRUE) {
      $this->httpDelete("delete-file-or-folder-tree", $entityIdOrPath);
    }
    else {
      $this->httpDelete("delete-file-or-folder", $entityIdOrPath);
    }
  }

  /**
   * Deletes a folder, optionally recursively.
   *
   * The item indicated by an integer ID or a path must be a folder.
   * If $recurse is FALSE, the folder must be empty. If $recurse is TRUE,
   * non-empty folders will have their content deleted first, recursing
   * as necessary through subfolders.
   *
   * @param int|string $entityIdOrPath
   *   The numeric entity ID or string path for a remote folder.
   * @param bool $recurse
   *   (optional, default = FALSE) When TRUE, non-empty folders are deleted
   *   recursively, including any subfolders and their content. When FALSE,
   *   the operation only deletes empty folders.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path is an empty string.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The item does not exist.
   *   - The item is not a folder.
   *   - The item is locked by another process.
   *
   * @see ::deleteFile()
   * @see ::deleteFileOrFolder()
   */
  public function deleteFolder($entityIdOrPath, bool $recurse = FALSE) {
    //
    // Validate
    // --------
    // If the path is a string, it cannot be empty. Further checking of
    // the path, or of integer entity IDs, must be done on the server.
    if (is_string($entityIdOrPath) === TRUE &&
        empty($entityIdOrPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($recurse === TRUE) {
      $this->httpDelete("delete-folder-tree", $entityIdOrPath);
    }
    else {
      $this->httpDelete("delete-folder", $entityIdOrPath);
    }
  }

  /*--------------------------------------------------------------------
   *
   * POST requests.
   *
   *--------------------------------------------------------------------*/

  /**
   * Creates a new top-level folder.
   *
   * A new top-level folder is created with the selected name in the
   * user's top-level folder list. An exception is thrown if the name
   * is already in use.
   *
   * @param string $name
   *   The name of the new top-level folder.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the name is empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The user does not have necessary permissions.
   *   - The top level folder list is locked by another process.
   *   - The name is malformed.
   *   - The new name would cause a collision.
   *
   * @see ::newFolder()
   */
  public function newRootFolder(string $name) {
    //
    // Validate
    // --------
    // The name cannot be empty. Checking that the name is well formed
    // must be done on the server.
    if (empty($name) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty new remote folder name.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPost(
      "new-rootfolder",
      "/",
      [
        'name' => [
          0 => [
            'value' => $name,
          ],
        ],
      ]);
  }

  /**
   * Creates a new folder in a parent folder.
   *
   * A new folder with the selected name is created in the parent folder.
   * An exception is thrown if the name is already in use.
   *
   * @param string $path
   *   The string path for a remote parent folder.
   * @param string $name
   *   The name of the new folder.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or name are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The parent folder does not exist.
   *   - The user does not have necessary permissions.
   *   - The parent folder is locked by another process.
   *   - The name is malformed.
   *   - The new name would cause a collision.
   *
   * @see ::newRootFolder()
   */
  public function newFolder(string $path, string $name) {
    //
    // Validate
    // --------
    // The path and name cannot be empty. Checking that the path and name
    // are well formed, and that the path refers to an existing folder must be
    // done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote parent folder path.");
    }

    if (empty($name) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty new remote folder name.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPost(
      "new-folder",
      $path,
      [
        'name' => [
          0 => [
            'value' => $name,
          ],
        ],
      ]);
  }

  /*--------------------------------------------------------------------
   *
   * PATCH requests.
   *
   *--------------------------------------------------------------------*/

  /**
   * Renames a file or folder.
   *
   * The file or folder is named without moving it. An exception is
   * thrown if the new name is already in use.
   *
   * @param string $path
   *   The string path for a remote file or folder.
   * @param string $name
   *   The new name for the item.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or name are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item to rename does not exist.
   *   - The user does not have necessary permissions.
   *   - The item is locked by another process.
   *   - The name is malformed.
   *   - The rename would cause a collision.
   *
   * @see ::move()
   */
  public function rename(string $path, string $name) {
    //
    // Validate
    // --------
    // The path and name cannot be empty. Checking that the path and name
    // are well formed, and that the path refers to an existing item must be
    // done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    if (empty($name) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty new remote file or folder name.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPatch(
      "update-entity",
      $path,
      '',
      [
        'name' => [
          0 => [
            'value' => $name,
          ],
        ],
      ]);
  }

  /**
   * Updates a file or folder field.
   *
   * The value for the selected field in the file or folder is updated
   * to the new value. An exception is thrown if the field is not known
   * or the value is not valid.
   *
   * Only simple fields may be updated using this method.
   *
   * @param string $path
   *   The string path for a remote file or folder.
   * @param string $fieldName
   *   The name of a simple field in the file or folder.
   * @param string $fieldValue
   *   The new value for the field.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the path or field name are empty.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - The path is malformed.
   *   - The item to rename does not exist.
   *   - The user does not have necessary permissions.
   *   - The item is locked by another process.
   *   - The name is malformed.
   *   - The rename would cause a collision.
   *
   * @see ::rename()
   */
  public function update(string $path, string $fieldName, string $fieldValue) {
    //
    // Validate
    // --------
    // The path and field name cannot be empty. Checking that the path,
    // field name, and value are well formed, and that the path refers to an
    // existing item must be done on the server.
    if (empty($path) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    if (empty($fieldName) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty field name.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    $this->httpPatch(
      "update-entity",
      $path,
      '',
      [
        $fieldName => [
          0 => [
            'value' => $fieldValue,
          ],
        ],
      ]);
  }

  /**
   * Moves a file or folder to a new location.
   *
   * This method is modeled after the way the Linux/macOS/BSD "mv" command
   * operates. It supports moving an item, renaming an item in place, or
   * moving and renaming at the same time.
   *
   * The $fromPath must refer to an existing file or folder to be moved
   * and/or renamed.
   *
   * The $toPath may be one of:
   * - A "/" to refer to the top-level folder list.
   * - A path to an existing file or folder.
   * - A path to a non-existant item within an existing parent folder.
   *
   * If $toPath is "/", $fromPath must refer to a folder since files cannot be
   * moved into "/". The moved folder will have the same name as in $fromPath.
   * If there is already an item with the same name in "/", the move will
   * fail unless $overwrite is TRUE.
   *
   * If $toPath refers to a non-existant item, then the item referred to
   * by $fromPath will be moved into the $toPath's parent folder and
   * renamed to use the last name on $toPath. If $toPath's parent folder
   * is "/", then $fromPath must refer to a folder since files cannot be
   * moved into "/".
   *
   * If $toPath refers to an existing folder, the file or folder referred
   * to by $fromPath will be moved into the $toPath folder and retain its
   * current name. If there is already an item with that name in the
   * $toPath folder, the move will fail unless $overwrite is TRUE.
   *
   * If $toPath refers to an existing file, the move will fail unless
   * $overwrite is TRUE. If overwrite is allowed, the item referred to by
   * $fromPath will be moved into the $toPath item's parent folder and
   * renamed to have th last name in $toPath. If $toPath's parent folder
   * is "/", then $fromPath must refer to a folder since files cannot be
   * moved into "/".
   *
   * In any case where an overwrite is required, if $overwrite is FALSE
   * the operation will fail. Otherwise the item to overwrite will be
   * deleted before the move and/or rename takes place.
   *
   * The user must have permission to modify the item referred to by $fromPath.
   * They user must have permission to modify the folder into which the
   * item will be placed. When moving a folder to "/", the user must have
   * permission to create a new top-level folder. And when overwriting an
   * existing item, the user must have permission to delete that item.
   *
   * @param string $fromPath
   *   The string path for a remote file or folder to move.
   * @param string $toPath
   *   The string path to the remote parent folder to receive the moved item.
   *   Use "/" to move a folder to the root folder list.
   * @param bool $overwrite
   *   (optional, default = FALSE) When TRUE, a move of an item into a folder
   *   that already has an item of the same name will overwrite that item.
   *   When FALSE, an error is generated instead.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to move/rename does not exist.
   *   - The destination folder does not exist.
   *   - The item is the wrong type for the destination.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *   - The move/rename would cause a collision, but $overwrite is FALSE.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if either path is empty.
   *
   * @see ::rename()
   */
  public function move(string $fromPath, string $toPath, bool $overwrite = TRUE) {
    //
    // Validate
    // --------
    // Neither path can be empty. Checking that the paths are well formed
    // and refer to appropriate entities must be done on the server.
    if (empty($fromPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    if (empty($toPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote destination folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($overwrite === TRUE) {
      $this->httpPatch("move-overwrite", $fromPath, $toPath);
    }
    else {
      $this->httpPatch("move-no-overwrite", $fromPath, $toPath);
    }
  }

  /**
   * Copies a file or folder to a new location.
   *
   * This method is modeled after the way the Linux/macOS/BSD "cp" command
   * operates. It supports copying one or more items to a new destination.
   *
   * The $fromPath must refer to an existing file or folder to be copied
   * and optionally renamed.
   *
   * The $toPath may be one of:
   * - A "/" to refer to the top-level folder list.
   * - A path to an existing file or folder.
   * - A path to a non-existant item within an existing parent folder.
   *
   * If $toPath is "/", $fromPath must refer to a folder since files cannot be
   * copied into "/". The copied folder will have the same name as in $fromPath.
   * If there is already an item with the same name in "/", the copy will
   * fail unless $overwrite is TRUE.
   *
   * If $toPath refers to a non-existant item, then the item referred to
   * by $fromPath will be copied into the $toPath's parent folder and
   * renamed to use the last name on $toPath. If $toPath's parent folder
   * is "/", then $fromPath must refer to a folder since files cannot be
   * copied into "/".
   *
   * If $toPath refers to an existing folder, the file or folder referred
   * to by $fromPath will be copied into the $toPath folder and retain its
   * current name. If there is already an item with that name in the
   * $toPath folder, the copy will fail unless $overwrite is TRUE.
   *
   * If $toPath refers to an existing file, the copy will fail unless
   * $overwrite is TRUE. If overwrite is allowed, the item referred to by
   * $fromPath will be copied into the $toPath item's parent folder and
   * renamed to have th last name in $toPath. If $toPath's parent folder
   * is "/", then $fromPath must refer to a folder since files cannot be
   * copied into "/".
   *
   * In any case where an overwrite is required, if $overwrite is FALSE
   * the operation will fail. Otherwise the item to overwrite will be
   * deleted before the copy takes place.
   *
   * The user must have permission to view the item referred to by $fromPath.
   * They user must have permission to modify the folder into which the
   * item will be placed, and permission to create the new item there.
   * When copying a folder to "/", the user must have permission to create
   * a new top-level folder. And when overwriting an existing item, the
   * user must have permission to delete that item.
   *
   * @param string $fromPath
   *   The string path for a remote file or folder.
   * @param string $toPath
   *   The string path to the remote parent folder to receive the copied item.
   *   Use "/" to copy a folder to the root folder list.
   * @param bool $overwrite
   *   (optional, default = FALSE) When TRUE, a copy of an item into a folder
   *   that already has an item of the same name will overwrite that item.
   *   When FALSE, an error is generated instead.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to copy does not exist.
   *   - The destination folder does not exist.
   *   - The item is the wrong type for the destination.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *   - The copy would cause a collision, but $overwrite is FALSE.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if either path is empty.
   *
   * @see ::move()
   */
  public function copy(string $fromPath, string $toPath, bool $overwrite = TRUE) {
    //
    // Validate
    // --------
    // Neither path can be empty. Checking that the paths are well formed
    // and refer to appropriate entities must be done on the server.
    if (empty($fromPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    if (empty($toPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote destination folder path.");
    }

    //
    // Execute
    // -------
    // Issue the request.
    if ($overwrite === TRUE) {
      $this->httpPatch("copy-overwrite", $fromPath, $toPath);
    }
    else {
      $this->httpPatch("copy-no-overwrite", $fromPath, $toPath);
    }
  }

  /**
   * Downloads a remote file or folder to a local file or folder.
   *
   * @param string $remotePath
   *   The string path for a remote file or folder.
   * @param string $localPath
   *   The string path for a local file or folder.
   * @param bool $overwrite
   *   (optional, default = FALSE) When TRUE and $localPath refers to an
   *   existing file, the file will be deleted before the download is done.
   *   When FALSE, an existing local file will cause an exception.
   *
   * @return string
   *   Returns the absolute path to the newly downloaded file. If $localPath
   *   is a folder, then the downloaded file path will start with that path,
   *   followed by the file name as returned by the server.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to download does not exist.
   *   - The item to download is not a file or folder.
   *   - The user does not have necessary permissions.
   *   - One of the item's involved is locked by another process.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception on a client error, including the following
   *   conditions:
   *   - The remote path is empty.
   *   - The local path is empty.
   *   - The local path does not indicate a folder that exists.
   *   - The local path does not indicate a folder that can be written to.
   *   - The local path indicates a file that already exists.
   *
   * @see ::move()
   */
  public function download(
    string $remotePath,
    string $localPath,
    bool $overwrite = FALSE) {
    //
    // Validate
    // --------
    // Neither path can be empty. Checking that the remote path is well formed
    // and refers to an appropriate entity must be done on the server.
    if (empty($remotePath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty remote file or folder path.");
    }

    if (empty($localPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Empty local file path.");
    }

    //
    // Create a temporary local file
    // -----------------------------
    // The downloaded data will be placed into a new local file that must
    // be created now. The open file handle is then passed to CURL.
    //
    // If the local path is for a directory, then the local file name will
    // be a temporary name. At the end of the file download the temporary
    // name will be changed to the name returned by the server.
    $cleanLocalPath = realpath($localPath);
    if (is_dir($cleanLocalPath) === TRUE) {
      // Create a temporary file path in the directory.
      $tmpLocalPath = tempnam($cleanLocalPath, 'foldershare');
      $renameFile = TRUE;
    }
    elseif (is_file($cleanLocalPath) === TRUE) {
      // The file already exists.
      if ($overwrite === FALSE) {
        throw new \InvalidArgumentException(
          "A local file with that name already exists.");
      }

      if (@unlink($cleanLocalPath) === FALSE) {
        throw new \InvalidArgumentException(
          "A local file with that name already exists and cannot be overwritten.");
      }

      $tmpLocalPath = $cleanLocalPath;
      $renameFile = FALSE;
    }
    else {
      // The path appears to be a name for a new file that doesn't exist yet.
      $tmpLocalPath = $cleanLocalPath;
      $renameFile = FALSE;
    }

    // Create and open the file so that CURL can save attached data into it.
    $tmpLocalFile = @fopen($tmpLocalPath, 'wb');
    if ($tmpLocalFile === FALSE) {
      throw new \InvalidArgumentException(
        "Cannot create a local file to receive the remote file contents.");
    }

    //
    // Create headers
    // --------------
    // The headers specify the GET operation and the source path, if any.
    $headers = [];

    // Set the operation.
    $headers[] = 'X-FolderShare-Get-Operation: download';

    // Make sure the path is safe. HTTP headers primarily support ASCII,
    // while paths may include multi-byte characters. Use URL encoding
    // to add them to the header.
    $headers[] = 'X-FolderShare-Source-Path: ' . rawurlencode($remotePath);

    //
    // Create URL
    // ----------
    // The GET URL includes:
    // - The host name.
    // - The canonical web services path.
    // - The entity ID (even if one is not used).
    // - The return syntax.
    $url = $this->hostName . self::URL_GET . '/0?_format=json';

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    //
    // Authentication settings should be included.
    //
    // A CSRF token is not required.
    $this->printVerbose("Issuing GET for download");
    $options                         = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]            = $url;
    $options[CURLOPT_HTTPGET]        = TRUE;
    $options[CURLOPT_FILE]           = $tmpLocalFile;
    $options[CURLOPT_HTTPHEADER]     = $headers;
    $options[CURLOPT_HEADERFUNCTION] = [$this, 'downloadHeaderCallback'];

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ---------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $this->downloadFilename = '';

    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    // Close the temp file. It may or may not have received anything useful.
    fclose($tmpLocalFile);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      @unlink($tmpLocalPath);
      $message = $this->getNiceHttpErrorMessage($httpCode);
      $this->printVerbose("  Server failed with HTTP code $httpCode");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A 200 is returned when there is a file.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
        break;

      default:
        // On an error, the error message has been written to the temp file.
        // Read it in, delete the file, and parse the message (if any).
        $content = file_get_contents($tmpLocalPath);
        @unlink($tmpLocalPath);

        if ($content !== FALSE) {
          $content = json_decode($content, TRUE);
        }

        if (empty($content) === FALSE && isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }

    // Everything worked. Rename the temp file using the file name from
    // the HTTP header.
    //
    // Using the HTTP header's name is necessary if the download is for
    // a folder. The server automatically ZIPs that folder into a file
    // and sends the file. The name of that ZIP file is what we want for
    // the name of the final file, not the name of the directory.
    if ($renameFile === TRUE) {
      $finalPath = $cleanLocalPath . '/' . $this->downloadFilename;
      rename($tmpLocalPath, $finalPath);
    }
    else {
      $finalPath = $cleanLocalPath;
    }

    $this->printVerbose("  Request complete");
    return $cleanLocalPath;
  }

  /**
   * Responds to an HTTP header receipt during a file download.
   *
   * This method is called by CURL while downloading a file. Each call
   * passes a line from the incoming HTTP header. The line is parsed
   * to look for the "Content-Disposition", which includes the name
   * of the file being downloaded. This name is then saved for later use.
   *
   * @param resource $curlSession
   *   The resource for the current CURL session.
   * @param string $line
   *   The HTTP header line to parse.
   *
   * @return int
   *   Returns the number of bytes in the incoming HTTP header line.
   */
  private function downloadHeaderCallback($curlSession, $line) {
    // Get the length (in bytes) of the incoming line. This must be
    // returned when the function is done.
    $lineBytes = strlen($line);

    // Split the line to get the header key and value.
    $parts = mb_split(':', $line, 2);
    if (count($parts) !== 2) {
      return $lineBytes;
    }

    // We only want the content disposition header line.
    if ($parts[0] !== 'Content-Disposition') {
      return $lineBytes;
    }

    // Extract the file name from the line, if there is one.
    $found = [];
    if (mb_ereg('filename="(.*)"', $parts[1], $found) === FALSE) {
      return $lineBytes;
    }

    // Save the file name to use at the end of the download.
    $this->downloadFilename = $found[1];
    return $lineBytes;
  }

  /**
   * Uploads a local file to a remote file.
   *
   * The local path must refer to a file, not a directory. Directory uploading
   * is not yet supported.
   *
   * @param string $localPath
   *   The string path for a local file or folder.
   * @param string $remotePath
   *   The string path for a remote file or folder.
   *
   * @throws \RuntimeException
   *   Throws an exception on a communications or server error, including
   *   the following conditions:
   *   - The host cannot be contacted, such a with a bad host name.
   *   - The host refuses contact, such as with bad authentication credentials.
   *   - The host does not support the operation.
   *   - Either path is malformed.
   *   - The item to upload does not exist.
   *   - The user does not have necessary permissions to create a file.
   *   - One of the item's involved is locked by another process.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception on a client error, including the following
   *   conditions:
   *   - The remote path is empty.
   *   - The local path is empty.
   *   - The local path does not indicate a file that exists.
   *   - The local path does not indicate a regular file.
   *   - The local path does not indicate a file that can be read.
   */
  public function upload(string $localPath, string $remotePath) {
    //
    // Validate
    // --------
    // Neither path can be empty. Checking that the remote path is well formed
    // and refers to an appropriate entity must be done on the server.
    if (empty($remotePath) === TRUE) {
      throw new \InvalidArgumentException(
        "Programmer error: Empty remote file or folder path for upload.");
    }

    if (empty($localPath) === TRUE) {
      throw new \InvalidArgumentException(
        "Programmer error: Empty local file path for upload.");
    }

    if (file_exists($localPath) === FALSE) {
      throw new \InvalidArgumentException(
        "The local file does not exist.\nPlease check your local file path for typos.");
    }

    if (is_file($localPath) === FALSE) {
      if (is_dir($localPath) === TRUE) {
        throw new \InvalidArgumentException(
          "Uploading directories is not yet supported.\nPlease upload files individually.");
      }

      if (is_link($localPath) === TRUE) {
        throw new \InvalidArgumentException(
          "Uploading symbolilc links is not supported.\nOnly files can be uploaded.");
      }

      throw new \InvalidArgumentException(
        "Uploading devices, sockets, and other special file types is not supported.\nOnly files can be uploaded.");
    }

    if (is_readable($localPath) === FALSE) {
      throw new \InvalidArgumentException(
        "The local file cannot be read.\nPlease check that you have permission to read the file.");
    }

    //
    // Confirm cookie authentication
    // -----------------------------
    // As of Drupal 8.5 (and earlier), the REST module's base classes do
    // not support access to the incoming request and attached uploaded files.
    // This prevents us from using a normal REST upload path.
    //
    // Instead, we must POST to a form outside of the REST configuration.
    // This form requires cookie authentication and a custom POST process
    // below.
    if ($this->authenticationType !== self::AUTHENTICATION_COOKIE) {
      throw new \RuntimeException(
        "File upload is not supported.
The current connection with the host is not using cookie-based authentication,
which is required for file uploading. Please contact the host administrator
to enable cookie-based authentication.");
    }

    //
    // Create URL
    // ----------
    // The GET/POST URL includes:
    // - The host name.
    // - The file upload path.
    $url = $this->hostName . self::URL_UPLOAD;

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    $this->printVerbose("Issuing GET for file upload form");
    $options                  = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]     = $url;
    $options[CURLOPT_HTTPGET] = TRUE;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue GET
    // ----------
    // Issue an HTTP GET to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    switch ($httpCode) {
      case 200:
      case 201:
        break;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }

    //
    // Find form token
    // ---------------
    // The GET above gets a web page upload form that contains hidden
    // fields added by Drupal for:
    // - form_build_id.
    // - form_token.
    // - form_id.
    //
    // The form_token is used as a validation mechanism by Drupal when
    // doing a form POST. We need that ID to add to the POST fields below.
    $matches = [];
    preg_match('/form_build_id" *value="([^"]*)"/', $content, $matches);
    $formBuildId = $matches[1];

    preg_match('/form_token" *value="([^"]*)"/', $content, $matches);
    $formToken = $matches[1];

    preg_match('/form_id" *value="([^"]*)"/', $content, $matches);
    $formId = $matches[1];

    //
    // Create POST fields
    // ------------------
    // The POST fields contain:
    // - The form token from above.
    // - The file to upload.
    // - The path of the upload destination.
    $postFields = [
      'form_build_id' => $formBuildId,
      'form_id'       => $formId,
      'form_token'    => $formToken,
      'files[file]'   => new \CURLFile($localPath),
      'path'          => $remotePath,
      'op'            => 'Upload',
    ];

    //
    // Set up request
    // --------------
    // Get common CURL options and update them with specifics of this request.
    $this->printVerbose("Issuing POST for file upload");
    $options                      = $this->getCommonCurlOptions(TRUE);
    $options[CURLOPT_URL]         = $url;
    $options[CURLOPT_POST]        = 1;
    $options[CURLOPT_SAFE_UPLOAD] = TRUE;
    $options[CURLOPT_POSTFIELDS]  = $postFields;

    curl_reset($this->curlSession);
    curl_setopt_array($this->curlSession, $options);

    //
    // Issue POST
    // ----------
    // Issue an HTTP POST to the web server. There are two types of errors:
    // - Communications errors reported by CURL as error numbers.
    // - Web site errors reported as bad HTTP codes.
    //
    // The returned content varies depending upon the operation.
    $content  = curl_exec($this->curlSession);
    $httpCode = curl_getinfo($this->curlSession, CURLINFO_HTTP_CODE);
    $errno    = curl_errno($this->curlSession);

    if ($errno !== 0) {
      // Communications error. Something went wrong with Curl or with
      // its communications with the server.
      $message = $this->getNiceCurlErrorMessage($errno);
      $this->printVerbose("  CURL failed with error code $errno");
      $this->printVerbose("  $message");
      throw new \RuntimeException($message);
    }

    // Decode JSON content.
    if (empty($content) === FALSE) {
      $content = json_decode($content, TRUE);
    }

    // Check for error codes. The following are standard HTTP success codes:
    // - 200 = OK.
    // - 201 = Created.
    // - 202 = Accepted.
    // - 203 = Non-authoritative information.
    // - 204 = No content.
    // - 205 = Reset content.
    // - 206 = Partial content.
    // - 207 = Multi-status.
    // - 208 = Already reported.
    // - 226 = IM used.
    //
    // A POST always creates content, so all successful requests return 201.
    //
    // All other standard success codes are unacceptable.
    switch ($httpCode) {
      case 200:
      case 201:
        $this->printVerbose("  Request complete");
        if (empty($content) === TRUE) {
          return NULL;
        }
        return $content;

      default:
        if (isset($content['message']) === TRUE) {
          $message = $content['message'];
        }
        else {
          $message = $this->getNiceHttpErrorMessage($httpCode);
        }

        $this->printVerbose("  Server failed with HTTP code $httpCode");
        $this->printVerbose("  $message");
        throw new \RuntimeException($message);
    }
  }

}


/**
 * Provides static functions that assist in specialized content formatting.
 *
 * Intended as a companion class to FolderShareConnect, this class provides
 * optional formatting utility functions to present returned content in
 * special ways.
 */
class FolderShareFormat {

  /*--------------------------------------------------------------------
   *
   * Key-value formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a nested key-value array as text.
   *
   * The keys and values of the array are returned as multi-line text in
   * two columns holding the key and value. Rows are optionally indented.
   *
   * Nested arrays are handled by recursing.
   *
   * @param array $response
   *   The key-value response to convert to text.
   * @param string $indent
   *   (optional, default = '  ') The indent for each key-value line in
   *   the result.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsText(
    array $response,
    string $indent = '') {

    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response.
    if (empty($response) === TRUE) {
      return '';
    }

    //
    // Prepare
    // -------
    // Make a first pass through all keys to find the longest key.
    // This will become the column width below.
    $maxLength = 0;
    foreach (array_keys($response) as $key) {
      $length = mb_strlen($key);
      if ($length > $maxLength) {
        $maxLength = $length;
      }
    }

    // Add one for a ':'.
    ++$maxLength;

    //
    // Generate output
    // ---------------
    // Make a second pass to format everything. Use the maximum key length
    // to set a uniform field size for outputing key names.
    $format = "$indent%-$maxLength" . "s %s\n";
    $text = '';
    foreach ($response as $key => $value) {
      // If the value is a scalar, convert it to a string and output.
      if (is_scalar($value) === TRUE) {
        $text .= sprintf($format, $key . ':', $value);
        continue;
      }

      if (empty($value) === TRUE) {
        $text .= sprintf($format, $key . ':', '');
        continue;
      }

      // Otherwise the value must be an array. Sweep through the array to
      // see if all of its values are scalars and its keys are numeric.
      // This is the case for simple lists.
      $simpleList = TRUE;
      foreach ($value as $k => $v) {
        if (is_int($k) === FALSE || is_scalar($v) === FALSE) {
          $simpleList = FALSE;
          break;
        }
      }

      // If the array is a simple list, format the array as a comma-separated
      // list.
      if ($simpleList === TRUE) {
        $text .= sprintf($format, $key . ':', implode(', ', $value));
        continue;
      }

      // Otherwise recurse.
      $indent2 = $indent . '  ';
      $text .= sprintf($format, $key . ':', '');
      $text .= self::formatAsText($value, $indent2);
    }

    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Linux-style formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a single entity similar to the output of a Linux 'stat' command.
   *
   * The Linux 'stat' command prints information about a file, directory,
   * or device. It has two primary formats:
   *
   * - (default) A full format shows multiple lines of text with key-value
   *   pairs giving the file name, size, permissions, etc.
   *
   * - A terse format shows a single line of text that condenses the most
   *   important values, including the file name, size, permissions, etc.
   *
   * This method takes 'stat' key-value data from FolderShare and formats
   * it in a full-like or terse-like output that includes essential values
   * for a FolderShare entity. It does not support format control arguments.
   *
   * Linux, BSD, macOS, and others all have 'stat' commands, but their
   * formats differ. This method outputs in a format similar to Linux.
   *
   * The Linux 'stat' output is not particularly user-friendly. Linux users
   * are more likely to be familiar with 'ls' output, which provides similar
   * information.
   *
   * <B>Full mode (default)</B><BR>
   * The full multi-line output of Linux 'stat' includes:
   * - File name.
   * - Size.
   * - Number of blocks.
   * - IO block size.
   * - File type (e.g. "regular file" vs. "device").
   * - Device.
   * - Inode number.
   * - Number of hard links.
   * - Permissions mode as hex and text.
   * - User as ID and account name.
   * - Group as ID and group name.
   * - Time of last access as text.
   * - Time of last modification as text.
   * - Time of last status change as text.
   *
   * Some of these values have FolderShare equivalents, while others do not.
   * This method drops these values:
   * - Number of blocks.
   * - IO block size.
   * - Number of hard links.
   * - Group as ID and group name.
   * - Time of last access as text.
   *
   * And replaces these values:
   * - File type replaced with MIME type.
   * - Device replaced with host name.
   * - Inode number replaced with entity ID.
   * - Time of last status change replaced with creation date.
   *
   * This method also adds a few fields:
   * - Full path.
   * - Parent entity ID.
   * - Root entity ID.
   *
   * This method also slightly adjusts the Linux 'stat' names to be more
   * meaningful here:
   * - "Name" is used instead of the misleading "File", which Linux uses
   *   even for things that are not files.
   * - "Mime type" is used instead of the Linux "FileType".
   *
   * The output of this method looks like:
   * @code
   *   Path: "PATH"
   *   Name: "FILENAME"
   *   Size: SIZE         Mime type: TYPE
   *   Host: HOSTNAME     ID: ID  ParentID: ID  RootID: ID
   * Access: SHARING      Uid: (UID/ACCOUNT)
   * Modify: DATE
   * Create: DATE
   * @endcode
   *
   * <B>Terse mode</B><BR>
   * If the $terseMode argument is TRUE, a terse mode is returned instead
   * of the full version above.
   *
   * The terse output of Linux 'stat' is an alias for the format string:
   * - %n %s %b %f %u %g %D %i %h %t %T %X %Y %Z %W %o
   * where:
   * - %n = file name.
   * - %s = size.
   * - %b = number of blocks.
   * - %f = raw permission mode in hex.
   * - %u = user ID.
   * - %g = group ID.
   * - %D = device number in hex.
   * - %i = inode number.
   * - %h = number of hard links.
   * - %t = major device type in hex.
   * - %T = minor device type in hex.
   * - %X = time of last access as a timestamp.
   * - %Y = time of last modification as a timestamp.
   * - %Z = time of last status change as a timestamp.
   * - %o = optimal I/O transfer size hint.
   *
   * Some of these values have FolderShare equivalents, while others do not.
   * Rather than reduce the line to just the FolderShare values, this method
   * retains the columns of the Linux terse mode, but shows a '-' if the
   * value is not relevant.
   *
   * This method shows the following values:
   *   %n = file name
   *   %s = size
   *   %b = -
   *   %f = sharing status
   *   %u = user ID
   *   %g = -
   *   %D = host name
   *   %i = entity ID
   *   %h = -
   *   %t = -
   *   %T = -
   *   %X = -
   *   %Y = time of last modification as a timestamp
   *   %Z = time of creation as a timestamp
   *   %o = -
   *
   * @param array $response
   *   The key-value array response when querying a file or folder.
   * @param bool $terseMode
   *   (optional, default = FALSE) When TRUE, a terse one-line form of
   *   the information is created. Otherwise a multi-line form is created.
   *
   * @return string
   *   Returns a text representation of the response.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the $response array is not for an entity or
   *   list of entities.
   */
  public static function formatAsLinuxStat(
    array $response,
    bool $terseMode = FALSE) {
    //
    // Validate
    // --------
    // Make sure the given server response is key-value data for
    // a single entity or a list of entities.
    if (empty($response) === TRUE) {
      throw new \InvalidArgumentException(
        "Programmer error: Empty response array when formatting as 'stat'.");
    }

    if (isset($response['path']) === FALSE) {
      // The array is not for a single entity. Is it for a list of entities?
      foreach ($response as $r) {
        if (isset($r['path']) === FALSE) {
          throw new \InvalidArgumentException(
            "Programmer error: Response array is not in key-value form when formatting as 'stat'.");
        }
      }

      // Recurse to build the output for a list of entities.
      $text = '';
      foreach ($response as $r) {
        $text .= self::formatAsLinuxStat($r, $terseMode);
      }

      return $text;
    }

    //
    // Generate output
    // ---------------
    // Extract and format relevant values.
    //
    // The 'size' may not be present if a entity does not yet have a size
    // computed.
    //
    // The 'id' may not be present if the entity is a temporary false entity
    // for "/" or some other virtual entity.
    //
    // All other values should be present.
    //
    // Entity fields.
    $size     = (isset($response['size']) === TRUE) ?
      (string) $response['size'] : '-';
    $fileType = (isset($response['mime']) === TRUE) ?
      $response['mime'] : '-';
    $id       = (isset($response['id']) === TRUE) ?
      (string) $response['id'] : '-';
    $parentId = (isset($response['parentid']) === TRUE) ?
      (string) $response['parentid'] : '-';
    $rootId   = (isset($response['rootid']) === TRUE) ?
      (string) $response['rootid'] : '-';
    $modified = (isset($response['changed']) === TRUE) ?
      $response['changed'] : '-';
    $created  = (isset($response['created']) === TRUE) ?
      $response['created'] : '-';

    // Virtual fields.
    $path         = $response['path'];
    $modifiedDate = $response['changed-date'];
    $createdDate  = $response['created-date'];
    $permission   = $response['sharing-status'];
    $uid          = $response['user-id'];
    $accountName  = $response['user-account-name'];

    // Site info.
    $host = $response['host'];

    // Get the file name from the path. We cannot use PHP's 'basename'
    // since it uses the current OS's conventions ("locale") rather than
    // our generic conventions. We also need to be multi-byte safe.
    if ($path === '/') {
      $filename = $path;
    }
    else {
      $lastSlashPosition = mb_strrpos($path, '/');
      if ($lastSlashPosition === FALSE) {
        $filename = $path;
      }

      $filename = mb_substr($path, ($lastSlashPosition + 1));
    }

    // Format the output.
    $text = '';
    if ($terseMode === TRUE) {
      $text .= sprintf(
        "%s %s - %s %d - - %d - - - - %d %d -\n",
        $filename,
        $size,
        $permission,
        $uid,
        $id,
        $modified,
        $created);
    }
    else {
      $text .= sprintf(
        "%6s: \"%s\"\n",
        'Path',
        $path);
      $text .= sprintf(
        "%6s: \"%s\"\n",
        'Name',
        $filename);
      $text .= sprintf(
        "%6s: %-25s %s:     %s\n",
        'Size',
        $size,
        'Mime type',
        $fileType);
      $text .= sprintf(
        "%6s: %-25s %s: %-10s %s: %-10s %s: %-10s\n",
        'Host',
        $host,
        'ID',
        $id,
        'ParentID',
        $parentId,
        'RootID',
        $rootId);
      $text .= sprintf(
        "%6s: %-25s %s: (%d/%s)\n",
        'Mode',
        $permission,
        'Uid',
        $uid,
        $accountName);
      $text .= sprintf(
        "%6s: %s\n",
        'Modify',
        $modifiedDate);
      $text .= sprintf(
        "%6s: %s\n",
        'Create',
        $createdDate);
    }

    return $text;
  }

  /**
   * Formats an entity list similar to the output of a Linux 'ls' command.
   *
   * The Linux 'ls' command prints a list of files and folders. In its
   * default mode, file and folder names are shown in multiple columns
   * sized to fit on the screen. Several common options modify this output
   * to list one file per line and include more information. Some of the
   * most useful options are:
   * - '-l' = show a long form that adds the file's permissions, number of
   *   hard links, owner name, group name, size (in blocks), modified date,
   *   and file name.
   *
   * - '-s' = add the file's size in bytes.
   *
   * - '-i' = add the Inode number.
   *
   * - '-o' = omit the group name with paired with '-l'..
   *
   * There are many more options to Linux 'ls', but they are more obscure
   * and not relevant here.
   *
   * For this method, several options are supported to create a few common
   * output modes:
   *
   * - Short mode. File and folder names are output in mulitple columns
   *   sized to fit within an 80-character wide window. Output is sorted
   *   by the file name. If '-s' or '-i' options are given, the size and
   *   entity ID are included before each name.
   *
   * - Long mode. File and folder names are output with one per line,
   *   including attributes in a Linux style. Lines are sorted by the
   *   file name. The '-s' option is ignored because sizes are always
   *   shown in bytes. If '-i' is given, the entity ID is included at
   *   the start of each line. The group name is always skipped, as if
   *   '-o' were given. The number of hard links is always skipped
   *   since there is no such thing in FolderShare.
   *
   * The following values are available to show in short or long modes:
   * - Entity ID in place of Inode number.
   * - Sharing status in place of of Linux permissions.
   * - User account name.
   * - Size (always in bytes).
   * - Modification date.
   * - Name.
   *
   * The following formatting flags are supported:
   * | Flag   | Meaning                                          |
   * | ------ | ------------------------------------------------ |
   * | -F     | Add special symbols on files and folders.        |
   * | -i     | Include the inode number.                        |
   * | -l     | Show a long listing format.                      |
   * | -s     | Include the size of each item.                   |
   * | -S     | Sort by size.                                    |
   * | -t     | Sort by modification time.                       |
   *
   * @param array $response
   *   The key-value array response when querying a file or folder.
   * @param array $flags
   *   (optional, default = []) Linux 'ls' style command-line flags.
   *
   * @return string
   *   Returns a text representation of the response.
   *
   * @throws \InvalidArgumentException
   *   Throws an exception if the $response array is not for an entity or
   *   list of entities.
   */
  public static function formatAsLinuxLs(array $response, array $flags = []) {
    //
    // Validate
    // --------
    // Make sure the given server response is key-value data for
    // a single entity or a list of entities.
    if (empty($response) === TRUE) {
      // It is not an error to try and format an empty response array.
      // It could simply mean that a folder listing found nothing to list.
      return '';
    }

    if (isset($response['path']) === TRUE) {
      // Response is for a single entity. Make it an array of one entry
      // and continue.
      $response = [$response];
    }
    else {
      // The array is not for a single entity. Is it for a list of entities?
      foreach ($response as $r) {
        if (isset($r['path']) === FALSE) {
          throw new \InvalidArgumentException(
            "Programmer error: Response array is not in key-value form when formatting for 'ls'.");
        }
      }
    }

    //
    // Check options
    // -------------
    // Look for options we support.
    $longMode = FALSE;
    $showSize = FALSE;
    $showId = FALSE;
    $showSymbol = FALSE;
    $sortBy = 'name';

    foreach ($flags as $flag) {
      switch ($flag) {
        case '-F':
          $showSymbol = TRUE;
          break;

        case '-i':
          $showId = TRUE;
          break;

        case '-l':
          $longMode = TRUE;
          break;

        case '-s':
          $showSize = TRUE;
          break;

        case '-S':
          $sortBy = 'size';
          break;

        case '-t':
          $sortBy = 'changed';
          break;
      }
    }

    //
    // Sort
    // ----
    // For all modes, sort the response list by the file name. The sort is
    // case sensitive, so upper case names bubble to the top of the list.
    switch ($sortBy) {
      default:
      case 'name':
        usort(
          $response,
          function ($a, $b) {
            $aname = basename($a['path']);
            $bname = basename($b['path']);
            return ($aname < $bname) ? (-1) : 1;
          });
        break;

      case 'size':
        usort(
          $response,
          function ($a, $b) {
            if (isset($a['size']) === TRUE) {
              $asize = (float) $a['size'];
            }
            else {
              $asize = INF;
            }

            if (isset($b['size']) === TRUE) {
              $bsize = (float) $b['size'];
            }
            else {
              $bsize = INF;
            }

            return ($asize < $bsize) ? (-1) : 1;
          });
        break;

      case 'changed':
        usort(
          $response,
          function ($a, $b) {
            $atime = $a['changed'];
            $btime = $b['changed'];
            return ($atime < $btime) ? (-1) : 1;
          });
        break;
    }

    //
    // Generate output
    // ---------------
    // Extract and format relevant values.
    //
    // The 'size' may not be present if a folder does not yet have a size
    // computed. All other values are always present.
    if ($longMode === FALSE) {
      // Loop through the response and find the longest file name.
      $filenames = [];
      $maxLength = 0;
      foreach ($response as $r) {
        // Get the item name.
        $name = basename($r['path']);

        // Get a symbol suffix based on the kind, if any.
        if ($showSymbol === TRUE) {
          $kind = $r['kind'];
          if ($kind === 'folder' || $kind === 'rootfolder') {
            $name .= '/';
          }
        }

        // Save the name for the list below.
        $filenames[] = $name;

        // Keep track of the longest name.
        $length = mb_strlen($name);
        if ($length > $maxLength) {
          $maxLength = $length;
        }
      }

      // If the size and entity ID are included in the output, increase
      // the maximum length to account for the space they require.
      if ($showSize === TRUE) {
        $maxLength += (8 + 1);
      }

      if ($showId === TRUE) {
        $maxLength += (8 + 1);
      }

      // And add one for a space between columns.
      ++$maxLength;

      // Compute the number of columns of names in the output.
      // Allow a maximum of 80 characters to a line.
      //
      // (80 is an historical line length that dates back to Hollerith punch
      // card widths and FORTRAN, but it remains a common magic number of
      // terminal window widths).
      $n = count($response);
      $nColumns = ceil(80 / $maxLength);
      $nRows = (int) ($n / $nColumns);
      if (($nRows * $nColumns) !== $n) {
        ++$nRows;
      }

      // Generate output.
      $text = '';
      for ($i = 0; $i < $nRows; ++$i) {
        $rowText = '';
        for ($j = 0; $j < $nColumns; ++$j) {
          // Compute the index of the next response.
          $index = (($i * $nColumns) + $j);
          if ($index >= $n) {
            continue;
          }

          // Get values.
          $filename = $filenames[$index];
          $size = isset($response[$index]['size']) === TRUE ?
            (string) $response[$index]['size'] : '-';
          $id = $response[$index]['id'];

          // Format the item.
          $itemText = '';
          if ($showId === TRUE) {
            $itemText .= sprintf("%8d ", $id);
          }

          if ($showSize === TRUE) {
            $itemText .= sprintf("%8s ", $size);
          }

          $itemText .= sprintf("%-" . $maxLength . "s", $filename);
          if ($j === 0) {
            $rowText .= $itemText;
          }
          else {
            $rowText .= ' ' . $itemText;
          }
        }

        $text .= $rowText . "\n";
      }

      return $text;
    }

    // Generate output.
    $text = '';
    foreach ($response as $item) {
      // Get values.
      $filename     = basename($item['path']);
      $size         = isset($item['size']) === TRUE ? (string) $item['size'] : '-';
      $permission   = $item['sharing-status'];
      $accountName  = $item['user-account-name'];
      $id           = $item['id'];
      $modifiedDate = $item['changed-date'];

      // Get a symbol suffix based on the kind, if any.
      if ($showSymbol === TRUE) {
        $kind = $item['kind'];
        if ($kind === 'folder' || $kind === 'rootfolder') {
          $filename .= '/';
        }
      }

      // Format the row.
      $idText = '';
      if ($showId === TRUE) {
        $idText = sprintf("%8d ", $id);
      }

      $text .= sprintf("%s%7s %8s %8s %s %s\n",
        $idText,
        $permission,
        $accountName,
        $size,
        $modifiedDate,
        $filename);
    }

    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Usage report formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a usage report as text.
   *
   * The keys and values of the array are interpreted as a usage report
   * and formatted as a text table of values.
   *
   * @param array $response
   *   The key-value response to convert to text.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsUsage(array $response) {
    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response.
    if (empty($response) === TRUE) {
      return '';
    }

    // Make sure the response does appear to be usage information.
    if (isset($response['nRootFolders']) === FALSE) {
      throw new \InvalidArgumentException(
        "Programmer error: Response array is not in key-value form when formatting for usage data.");
    }

    //
    // Generate output
    // ---------------
    // Pull out user and host information and output that first.
    // Then map the remaining usage information to friendlier names
    // and output that as a key-value list.
    //
    // Get host and user.
    $host = (isset($response['host']) === TRUE) ?
      $response['host'] : 'Unknown host';

    if (isset($response['user-account-name']) === TRUE) {
      $userName = $response['user-account-name'];
    }
    elseif (isset($response['user-id']) === TRUE) {
      $userName = $response['user-id'];
    }
    else {
      $userName = 'Unknown user';
    }

    $text = "$host usage for $userName:\n";

    // Create an alternate usage array with user-friendly names.
    $alt = [];
    foreach ($response as $k => $r) {
      switch ($k) {
        case 'user-id':
        case 'user-account-name':
        case 'user-display-name':
        case 'host':
          break;

        case 'nRootFolders':
          $alt['Top folders'] = $r;
          break;

        case 'nFolders':
          $alt['Subfolders'] = $r;
          break;

        case 'nFiles':
          $alt['Files'] = $r;
          break;

        case 'nBytes':
          $alt['Bytes'] = $r;
          break;

        default:
          $alt[$k] = $r;
          break;
      }
    }

    $text .= self::formatAsText($alt, '  ');
    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Configuration report formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a configuration report as text.
   *
   * The keys and values of the array are interpreted as a configuration report
   * and formatted as a text table of values.
   *
   * @param array $response
   *   The key-value response to convert to text.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsConfiguration(array $response) {
    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response.
    if (empty($response) === TRUE) {
      return '';
    }

    //
    // Generate output
    // ---------------
    // Show the host first, then map the remaining information into
    // friendlier names and a better structure. Then output that as a
    // key-value list.
    //
    // Get host and user.
    $host = (isset($response['host']) === TRUE) ?
      $response['host'] : 'Unknown host';

    // Create an alternate configuration array with user-friendly names.
    $alt = [];
    $alt['Web services'] = [];
    $alt['File handling'] = [];
    $alt['Sharing'] = [];

    $showExtensions = TRUE;

    foreach ($response as $k => $r) {
      switch ($k) {
        case 'host':
          // Already handled.
          break;

        case 'GET':
        case 'POST':
        case 'DELETE':
        case 'PATCH':
          $webalt = [];
          foreach ($r as $kk => $rr) {
            switch ($kk) {
              case 'serializer-formats':
                $webalt['Formats'] = $rr;
                break;

              case 'authentication-providers':
                $webalt['Authentication'] = $rr;
                break;

              default:
                $webalt[$kk] = $rr;
            }
          }

          $alt['Web services'][$k] = $webalt;
          break;

        case 'file-restrict-extensions':
          $alt['File handling']['Restrict extensions'] = $r;
          if (is_bool($r) === TRUE && $r === FALSE) {
            $showExtensions = FALSE;
          }
          elseif (is_scalar($r) === TRUE &&
              (((string) $r) === "false") || ((string) $r) === "FALSE") {
            $showExtensions = FALSE;
          }
          break;

        case 'file-allowed-extensions':
          $alt['File handling']['Allowed extensions'] = $r;
          break;

        case 'file-maximum-upload-size':
          $alt['File handling']['Max upload size'] = $r;
          break;

        case 'file-maximum-upload-number':
          $alt['File handling']['Max upload number'] = $r;
          break;

        case 'sharing-allowed':
          $alt['Sharing']['Sharing enabled'] = $r;
          break;

        case 'sharing-allowed-with-anonymous':
          $alt['Sharing']['Public enabled'] = $r;
          break;

        default:
          if (isset($alt['Other']) === FALSE) {
            $alt['Other'] = [];
          }

          $alt['Other'][$k] = $r;
          break;
      }
    }

    if ($showExtensions === FALSE) {
      unset($alt['File handling']['Allowed extensions']);
    }

    $text = "$host configuration:\n";
    $text .= self::formatAsText($alt, '  ');
    return $text;
  }

  /*--------------------------------------------------------------------
   *
   * Version report formatting.
   *
   *--------------------------------------------------------------------*/

  /**
   * Formats a version number report as text.
   *
   * The keys and values of the array are interpreted as a version number
   * report and formatted as a text table of values.
   *
   * @param array $response
   *   The key-value response to convert to text.
   *
   * @return string
   *   The string representation.
   */
  public static function formatAsVersion(array $response) {
    //
    // Validate
    // --------
    // It is not an error to try and format an empty response array.
    // It could simply mean that there is no response. But it is unlikely.
    if (empty($response) === TRUE) {
      return '';
    }

    // Confirm that this does seem to be a version response.
    if (isset($response['client']) === FALSE) {
      throw new \InvalidArgumentException(
        "Programmer error: Response array is not in key-value form when formatting version data.");
    }

    //
    // Generate output
    // ---------------
    // The output has several rows:
    // - The application name and version.
    // - The client API name and version.
    // - The host server name.
    // - A list of server item names and versions.
    //
    // Normally all of these are present in a version request's response.
    // But to be robust we need to check for each one and have a fallback.
    $text = '';
    $indent = '  ';

    //
    // Print versions.
    //
    foreach (['client', 'server'] as $section) {
      if (isset($response[$section]) === FALSE) {
        continue;
      }

      if ($section === 'client') {
        $text .= "Client software\n";
      }
      elseif ($section === 'server') {
        if (isset($response['host']) === FALSE) {
          // If there is no host, then there cannot be server side version
          // numbers. Anything that might be present is bogus. Skip it.
          break;
        }

        $hostname = $response['host'];
        $text .= "\nWeb services at $hostname\n";
      }

      foreach ($response[$section] as $k => $v) {
        $name = $k;
        $version = '';

        if (isset($response[$section][$k]['name']) === TRUE) {
          $name = $response[$section][$k]['name'];
        }

        if (isset($response[$section][$k]['version']) === TRUE) {
          $version = ', version ' . $response[$section][$k]['version'];
        }

        $text .= "$indent$name$version\n";
      }
    }

    return $text;
  }

}

/**
 * @file
 * Issues command-line requests to a host using the FolderShare module.
 */



/**
 * This application name.
 */
const NAME = "FolderShare application";

/**
 * This application version number.
 */
const VERSION = "0.4.0 (January 2018)";

/**
 * Describes commands and their options.
 *
 * The associative array's keys are command names available for use on the
 * command line (e.g. "ls" and "stat"). For each command, an array of values
 * describes the command, including its help text, a list of supported
 * flags, its return formats, synonyms, and finally the name of the function
 * to invoke to execute the command.
 *
 * Command help:
 *
 * - 'synopsis' = a one-line note on the command name and options, similar to
 *   the synopsis line of a traditional Linux/macOS/BSD man page.
 *
 * - 'description' = a multiparagraph description of the command.
 *
 * - 'flags' = an associative array that lists no-argument flags for the
 *   command. For each flag, the array key names the flag, including leading
 *   dashes ("-" or "--" or both). The key's value is an associative array
 *   with keys for:
 *   - 'brief' = a one-line description of the flag.
 *   - 'synonyms' = an array of equivalent flag names. Defaults to empty.
 *
 * - 'synonyms' = an array of alternate names for the command. Defaults to
 *   empty.
 *
 * Command return format keys:
 *
 * - 'formats' = an array of return format names supported by the command.
 *   Known values are: 'full', 'keyvalue', 'text', and 'linux'.
 *
 * - 'defaultFormat' = the default format.
 *
 * Execution keys:
 *
 * - 'function' = the name of the function to invoke for the command.
 */
const COMMANDS = [
  //
  // GET HTTP operations supported.
  //
  //
  // GET version numbers.
  //
  'version' => [
    'synopsis' => 'version [OPTIONS]',
    'brief' => 'Show version numbers.',
    'description' =>
"Show version numbers for client and server software.

If a host name is provided, the host is contacted and its software version
numbers reported along with those for the client software. But if no host
name is provided, only client software version numbers are reported.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
    ],
    'formats' => [
      'full',
      'keyvalue',
      'text',
    ],
    'defaultFormat' => 'text',
    'function' => 'runVersion',
  ],

  //
  // GET server configuration.
  //
  'config' => [
    'synopsis' => 'config [OPTIONS]',
    'brief' => 'Show the host administrator configuration.',
    'description' =>
"Summarize the administrator configuration settings for the host.

Reported configuration values include:
  - A list of HTTP verbs supported by the host.
  - The serialization formats supported for each HTTP verb.
  - The authentication providers supported for each HTTP verb.
  - The maximum file upload size and number.
  - The file name extensions supported, if restrictions are enabled.
  - Whether shared and public content is supported.

This information is primiarily of interest to host administrators and to those
developing client-server software. The reported values cannot be altered
through this client software. Administrators may adjust their host's
configuration using the web interface to the REST and FolderShare modules.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
    ],
    'synonyms' => [
      'configuration',
    ],
    'formats' => [
      'full',
      'keyvalue',
      'text',
    ],
    'defaultFormat' => 'text',
    'function' => 'runConfig',
  ],

  //
  // GET user's usage.
  //
  'usage' => [
    'synopsis' => 'usage [OPTIONS]',
    'brief' => 'Show the user\'s storage use.',
    'description' =>
"Report the number of top-level folders, subfolders, files, and bytes in use
by the user on the host.

The user must have permission to create and modify remote files and folders.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
    ],
    'formats' => [
      'full',
      'keyvalue',
      'text',
    ],
    'defaultFormat' => 'text',
    'function' => 'runUsage',
  ],

  //
  // GET file or folder status.
  //
  'stat' => [
    'synopsis' => 'stat [OPTIONS] REMOTE_PATHS...',
    'brief' => 'Show the status of files and folders.',
    'description' =>
"Show detailed status for remote files or folders.

Status information includes the item's name, remote folder path, owner, size,
MIME type, numeric entity ID, parent entity ID, top-level folder entity ID,
creation date, modified date, and whether the item is private, shared with
others, or shared with the public.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the remote files and folders.

This command is similar to the 'stat' command on Linux, BSD, and macOS.",
    'flags' => [
      '-t' => [
        'brief' => 'Show a terse one-line version of the information.',
        'synonyms' => [
          '--terse',
        ],
      ],
      '--help' => [
        'brief' => 'Show this help information.',
      ],
    ],
    'synonyms' => [
      'status',
    ],
    'formats' => [
      'full',
      'keyvalue',
      'linux',
      'text',
    ],
    'defaultFormat' => 'linux',
    'function' => 'runStat',
  ],

  //
  // GET folder contents.
  //
  'ls' => [
    'synopsis' => 'ls [OPTIONS] REMOTE_PATHS...',
    'brief' => 'List files and folders.',
    'description' =>
"List remote files and folders.

The command supports a default short form and a long form with the '-l' option.
Both forms default to sorting items by name:
  - The short form lists item names in multiple columns.
  - The long form lists item names and attributes in a single-column list.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the remote files and folders.

This command is similar to the 'ls' command on Linux, BSD, and macOS.",
    'flags' => [
      '-d' => [
        'brief' => 'List folders without recursion.',
      ],
      '-F' => [
        'brief' => 'Mark folders by adding a "/" suffix.',
      ],
      '-i' => [
        'brief' => 'Show the numeric entity ID for each item.',
      ],
      '-l' => [
        'brief' => 'Show a long form that lists more detail.',
      ],
      '-R' => [
        'brief' => 'Recurse to list folder contents.',
      ],
      '-s' => [
        'brief' => 'Show the size, in bytes, for each item.',
      ],
      '-S' => [
        'brief' => 'Sort by size instead of name.',
      ],
      '-t' => [
        'brief' => 'Sort by modification time instead of name.',
      ],
      '--help' => [
        'brief' => 'Show this help information.',
      ],
    ],
    'synonyms' => [
      'list',
      'dir',
    ],
    'formats' => [
      'full',
      'keyvalue',
      'linux',
      'text',
    ],
    'defaultFormat' => 'linux',
    'function' => 'runLs',
  ],

  //
  // DELETE file or folder.
  //
  'rm' => [
    'synopsis' => 'rm [OPTIONS] REMOTE_PATHS...',
    'brief' => 'Remove files or folders.',
    'description' =>
"Remove remote files and and folders.

Use 'rm' without options to remove remote files. Use 'rm -d' to also remove
empty folders. Use 'rm -r' to recursively remove files and non-empty folders
and their contents, recursively.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to remove the remote files and folders.

This command is similar to the 'rm' command on Linux, BSD, and macOS.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-d' => [
        'brief' => 'Delete folders as well as files.',
        'synonyms' => [],
      ],
      '-f' => [
        'brief' => 'Force deletion to continue even after errors.',
        'synonyms' => [],
      ],
      '-r' => [
        'brief' => 'Recursively remove folders and their contents.',
        'synonyms' => [
          '-R',
        ],
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is deleted.',
        'synonyms' => [],
      ],
    ],
    'synonyms' => [
      'remove',
      'del',
      'delete',
    ],
    'formats' => [],
    'defaultFormat' => '',
    'function' => 'runRm',
  ],

  //
  // DELETE folder.
  //
  'rmdir' => [
    'synopsis' => 'rmdir [OPTIONS] REMOTE_PATHS...',
    'brief' => 'Remove empty folders.',
    'description' =>
"Remove remote empty folders.

Use 'rmdir' to remove remote empty folders. It is an error to attempt to
remove a non-empty folder.

To remove files and non-empty folders, use the 'rm -r' command instead.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to remove the remote folders.

This command is similar to the 'rmdir' command on Linux, BSD, and macOS.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is deleted.',
        'synonyms' => [],
      ],
    ],
    'formats' => [],
    'defaultFormat' => '',
    'function' => 'runRmdir',
  ],

  //
  // POST new root folder or subfolder.
  //
  'mkdir' => [
    'synopsis' => 'mkdir [OPTIONS] REMOTE_PATHS...',
    'brief' => 'Make new folders.',
    'description' =>
"Make new remote empty folders.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to create the remote folders.

This command is similar to the 'mkdir' command on Linux, BSD, and macOS.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is created.',
        'synonyms' => [],
      ],
    ],
    'formats' => [
      'full',
      'keyvalue',
    ],
    'defaultFormat' => 'keyvalue',
    'function' => 'runMkdir',
  ],

  //
  // PATCH name and/or location.
  //
  'mv' => [
    'synopsis' => 'mv [OPTIONS] REMOTE_PATHS... REMOTE_DESTINATION_PATH',
    'brief' => 'Move files and folders.',
    'description' =>
"Move remote files or folders.

The command has two forms:
  - With two paths, the command moves the file or folder indicated by the
    first path into the destination selected by the second path.

  - With more than two paths, the command moves the files and folders indicated
    by all of the paths, except the last, into the destination folder selected
    by the last path.

With two paths, if the destination does not exist, but its parent folder does,
the moved item will be moved into the parent and renamed to use the name in
the destination path.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to modify the remote folders.

This command is similar to the 'mv' command on Linux, BSD, and macOS.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-n' => [
        'brief' => 'Do not overwrite an existing file.',
        'synonyms' => [],
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is moved.',
        'synonyms' => [],
      ],
    ],
    'synonyms' => [
      'move',
    ],
    'formats' => [
      'full',
      'keyvalue',
    ],
    'defaultFormat' => 'keyvalue',
    'function' => 'runMv',
  ],

  //
  // PATCH to create a copy.
  //
  'cp' => [
    'synopsis' => 'cp [OPTIONS] REMOTE_PATHS... REMOTE_DESTINATION_PATH',
    'brief' => 'Copy files and folders.',
    'description' =>
"Copy remote files or folders.

The command has two forms:
  - With two paths, the command copies the file or folder indicated by the
    first path into the destination selected by the second path.

  - With more than two paths, the command copies the files and folders
    indicated by all of the paths, except the last, into the destination folder
    selected by the last path.

With two paths, if the destination does not exist, but its parent folder does,
the copied item will be copied into the parent and renamed to use the name in
the destination path.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to create and modify the remote files and
folders.

This command is similar to the 'cp' command on Linux, BSD, and macOS.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-n' => [
        'brief' => 'Do not overwrite an existing file.',
        'synonyms' => [],
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is copied.',
        'synonyms' => [],
      ],
    ],
    'synonyms' => [
      'copy',
    ],
    'formats' => [
      'full',
      'keyvalue',
    ],
    'defaultFormat' => 'keyvalue',
    'function' => 'runCp',
  ],

  //
  // PATCH to update fields.
  //
  'update' => [
    'synopsis' => 'update [OPTIONS] FIELD_NAME FIELD_VALUE REMOTE_PATHS...',
    'brief' => 'Update fields on files and folders.',
    'description' =>
"Update the value for a named field on remote files or folders.

Fields that may be updated include:
  - 'name' = the name of the remote file or folder (see also the 'mv' command).
  - 'description' = the text description of the remote file or folder.

Additional fields may be supported by third-party extensions or customizations
made on specific hosts.

Field values that are more than one word (such as a description's text) or that
include special characters (such as in HTML) should be surrounded by quotes.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to modify the remote files and folders.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is changed.',
        'synonyms' => [],
      ],
    ],
    'formats' => [
      'full',
      'keyvalue',
      'text',
    ],
    'defaultFormat' => 'text',
    'function' => 'runUpdate',
  ],

  //
  // GET to download file.
  //
  'get' => [
    'synopsis' => 'get [OPTIONS] REMOTE_PATH [LOCAL_PATH]',
    'brief' => 'Download files and folders.',
    'description' =>
"Download a remote file or folder indicated to the local host.

The first path indicates a remote file or folder to download, while the second
path selects the local host location in which to save the downloaded item. If
the second path is omitted, the current directory is used and the new local
file has the same name as the remote file.

When downloading a remote folder, that folder and its contents are first
compressed into a ZIP archive and that archive is returned as a file saved onto
the local host. The ZIP archive is not automatically un-zipped.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the remote files and folders, and create
the local file.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is downloaded.',
        'synonyms' => [],
      ],
    ],
    'synonyms' => [
      'download',
    ],
    'formats' => [],
    'defaultFormat' => '',
    'function' => 'runGet',
  ],

  //
  // POST to upload file.
  //
  'put' => [
    'synopsis' => 'put [OPTIONS] LOCAL_PATH REMOTE_PATH',
    'brief' => 'Upload files and folders.',
    'description' =>
"Upload a local file to a remote folder.

The first path selects a local file to upload, while the second path indicates
the remote location for the uploaded file.

Paths to remote files and folders must start with '/'. Wild cards are not
supported.

The user must have permission to view the local file and create the remote
files and folders.",
    'flags' => [
      '--help' => [
        'brief' => 'Show this help information.',
      ],
      '-v' => [
        'brief' => 'Show the name of each item as it is uploaded.',
        'synonyms' => [],
      ],
    ],
    'synonyms' => [
      'upload',
    ],
    'formats' => [],
    'defaultFormat' => '',
    'function' => 'runPut',
  ],
];

/*--------------------------------------------------------------------
 *
 * Help and error messages.
 *
 * These functions print error messages and help information.
 *
 *--------------------------------------------------------------------*/

/**
 * Prints help information for command line use.
 *
 * The printed information is written for users that add commands to
 * the Linux/macOS/BSD shell command line. The host, user name, password,
 * and other base options are listed.
 *
 * @param string $appPath
 *   The path to the application.
 */
function printCommandLineHelp(string $appPath) {
  $appName = basename($appPath);
  $helpStart = <<<EOT
Usage is: $appName [HOST_OPTIONS] [COMMAND] [OPTIONS]

Create, delete, change, and manage files and folders on a remote web site
that uses the FolderShare module.

Commands
--------

EOT;

  $helpEnd = <<<EOT

Add "--help" after any command to show its description and flags.

Host and account
----------------
All commands require a remote host and account:

  --host HOSTNAME   Select the host (and optional port) for the site.
  --username NAME   Specify the user login name on the site.
  --password PASS   Specify the user password on the site.

Example:
  $appName --host myhost -username me --password pw ls /

If the username and/or password are omitted, the command will prompt for them.

Additional options
------------------
  --help            Show this help information.
  --verbose         Be verbose while performing the operation.
  --version         Show application version numbers.
  --format type     Select how information is displayed:
                      auto     (default) Use an operation-specific default
                      full     Show full-detail nested-array output
                      keyvalue Show a table of key-value pairs
                      linux    Show a Linux-style output
                      text     Show key-value pairs as text

For Linux/macOS/BSD-style commands, the format type defaults to 'linux'
and output is formatted similar to those OS commands.

Example:
  $appName --host myhost --format full stat /myfolder

Paths
-----
Remote file and folder paths have the form:

  [SCHEME:][//USER]/PATH.

SCHEME is optional and one of:
  private  (default) Your files and folders.
  public   The host's public files and folders available to anyone.
  shared   The files and folders shared with you.

USER is optional and selects the user ID or account name. It is primarily
for the 'shared' scheme and defaults to the current user.

PATH is a file and folder path, separated by forward slashes. Wildcards are
not accepted. If a path contains spaces or special characters, the whole
path should be included in quotes.

Examples:
  $appName --host myhost ls /
  $appName --host myhost ls private:/
  $appName --host myhost ls public:/
  $appName --host myhost ls shared://johnson/

EOT;

  $help = $helpStart;

  $commandNames = array_keys(COMMANDS);
  sort($commandNames, (SORT_STRING | SORT_FLAG_CASE));

  foreach ($commandNames as $commandName) {
    $commandInfo = COMMANDS[$commandName];

    if (isset($commandInfo['brief']) === TRUE) {
      $brief = $commandInfo['brief'];
    }
    else {
      $brief = $commandName;
    }

    $help .= sprintf("  %-18s%s\n", $commandName, $brief);
  }

  $help .= $helpEnd;

  fwrite(STDOUT, $help);
}

/**
 * Prints help information for prompt use.
 *
 * The printed information is written for users that are using the interactive
 * prompt. The host, user name, password, and other base options are not listed
 * since they would already have been provided.
 *
 * @param string $appPath
 *   The path to the application.
 */
function printPromptHelp(string $appPath) {
  $helpStart = <<<EOT
Commands
--------

EOT;

  $helpEnd = <<<EOT

Add "--help" after any command to show its description and flags.

Paths
-----
Remote file and folder paths have the form:

  [SCHEME:][//USER]/PATH.

SCHEME is optional and one of:
  private  (default) Your files and folders.
  public   The host's public files and folders available to anyone.
  shared   The files and folders shared with you.

USER is optional and selects the user ID or account name. It is primarily
for the 'shared' scheme and defaults to the current user.

PATH is a file and folder path, separated by forward slashes. Wildcards are
not accepted. If a path contains spaces or special characters, the whole
path should be included in quotes.

Examples:
  ls /
  ls private:/
  ls public:/
  ls shared://johnson/

EOT;

  $help = $helpStart;

  $commandNames = array_keys(COMMANDS);
  $commandNames[] = 'help';
  $commandNames[] = 'quit';
  sort($commandNames, (SORT_STRING | SORT_FLAG_CASE));

  foreach ($commandNames as $commandName) {
    if ($commandName === 'help') {
      $brief = "Show this help information.";
    }
    elseif ($commandName === 'quit') {
      $brief = "Quit.";
    }
    else {
      $commandInfo = COMMANDS[$commandName];

      if (isset($commandInfo['brief']) === TRUE) {
        $brief = $commandInfo['brief'];
      }
      else {
        $brief = $commandName;
      }
    }

    $help .= sprintf("  %-18s%s\n", $commandName, $brief);
  }

  $help .= $helpEnd;

  fwrite(STDOUT, $help);
}

/**
 * Prints help information for a command.
 *
 * @param string $appName
 *   The name of this command-line application.
 * @param string $commandName
 *   The name of the command.
 */
function printCommandHelp(string $appName, string $commandName) {
  if (isset(COMMANDS[$commandName]) === FALSE) {
    // Unknown command. Print nothing.
    return;
  }

  $command = COMMANDS[$commandName];

  //
  // Print synopsis
  // --------------
  // Print a command-line template for the command.
  $synopsis = "Usage: $appName [HOST_OPTIONS] ";
  if (isset($command['synopsis']) === FALSE) {
    $synopsis .= $commandName;
  }
  else {
    $synopsis .= $command['synopsis'];
  }

  fwrite(STDOUT, "$synopsis\n");

  //
  // Print description
  // -----------------
  // Print a multi-line text description.
  $description = "\n";
  if (isset($command['description']) === TRUE) {
    $description .= $command['description'] . "\n";
  }

  fwrite(STDOUT, $description);

  //
  // Print flags (if any)
  // -----------
  // Print a list of flags and their descriptions.
  if (isset($command['flags']) === TRUE) {
    fwrite(STDOUT, "\nOptions:\n");

    // Get flag names then sort them.
    $flagNames = array_keys($command['flags']);
    sort($flagNames, (SORT_STRING | SORT_FLAG_CASE));

    // Print them out.
    $flagIndent = '  ';
    $flagHelpIndent = '      ';

    foreach ($flagNames as $flagName) {
      $flagInfo = &$command['flags'][$flagName];

      // Print the flag line, with synonyms.
      $flagLine = "$flagIndent$flagName";
      if (isset($flagInfo['synonyms']) === TRUE) {
        foreach ($flagInfo['synonyms'] as $flagSynonym) {
          $flagLine .= ", $flagSynonym";
        }
      }

      fwrite(STDOUT, "$flagLine\n");

      // Print the flag command.
      if (isset($flagInfo['brief']) === TRUE) {
        $helpLines = mb_split("\n", $flagInfo['brief']);
        foreach ($helpLines as $helpLine) {
          fwrite(STDOUT, "$flagHelpIndent$helpLine\n");
        }
      }
    }
  }

  //
  // Print command synonyms (if any)
  // ----------------------
  // Print a list of synonyms.
  if (isset($command['synonyms']) === TRUE) {
    $names = [$commandName];
    foreach ($command['synonyms'] as $synonym) {
      $names[] = $synonym;
    }
    sort($names, SORT_NATURAL);
    $text = implode(', ', $names);

    fwrite(STDOUT, "\nSynonyms:\n  $text\n");
  }
}

/**
 * Prints the client side version to STDERR and exits.
 */
function printVersionAndExit(array $options) {
  // Create a dummy server connection without a host or authentication.
  // Then get the version of the client side only.
  $dummyServer = new FolderShareConnect();
  $options['format'] = 'text';
  $text = runVersion($dummyServer, $options, FALSE);
  fwrite(STDERR, $text);
  exit(1);
}

/**
 * Prints an error message to STDERR and exits.
 *
 * @param string $appPath
 *   The path to the application.
 * @param string $message
 *   The error message.
 */
function printErrorAndExit(string $appPath, string $message) {
  $appName = basename($appPath, '.php');
  fwrite(STDERR, "$appName: $message\n");
  exit(1);
}

/*--------------------------------------------------------------------
 *
 * Command-line parsing.
 *
 * These functions parse the command line.
 *
 *--------------------------------------------------------------------*/

/**
 * Parses the command line and returns values.
 *
 * The command line is parsed and its values validated and returned in
 * an associative array.
 *
 * @param array $argv
 *   The array of command-line arguments.
 */
function parseCommandLine(array $argv) {
  //
  // Set initial values
  // ------------------
  // Get the application name and set up defaults for all values.
  $options = [];
  $appPath = $options['appPath'] = array_shift($argv);
  $appName = $options['appName'] = basename($appPath, '.php');

  // Connection options.
  $options['host'] = '';
  $options['username'] = '';
  $options['password'] = '';

  // Flags.
  $options['format'] = 'auto';
  $options['verbose'] = FALSE;

  // Command.
  $options['command'] = [];
  $options['paths'] = [];
  $options['flags'] = [];

  $showVersion = FALSE;

  $usage = "\nUse '--help' for a list of commands and options.";

  //
  // Parse arguments
  // ---------------
  // Loop through the arguments and look for options and commands.
  // When a command name is found, all further arguments are considered
  // part of that command.
  $n = count($argv);
  for ($i = 0; $i < $n; ++$i) {
    // The first argument that does not start with '-' is the command.
    // Add it to the command's argument list, along with all further
    // arguments. It is up to the command to parse them.
    $dash = mb_substr($argv[$i], 0, 1);
    if ($dash !== '-') {
      // Command found!
      $options['command'] = array_slice($argv, $i);
      break;
    }

    // Otherwise, parse generic options relating to the connection
    // or flags.
    //
    // Ignore one or two leading dashes while parsing options.
    $dashes = mb_substr($argv[$i], 0, 2);
    if ($dashes === '--') {
      $arg = mb_substr($argv[$i], 2);
    }
    else {
      $arg = mb_substr($argv[$i], 1);
    }

    switch ($arg) {
      // Immediate response options.
      case 'help':
        // Print help information and stop.
        printCommandLineHelp($appName);
        exit(0);

      case 'version':
        // Print application version and stop.
        $showVersion = TRUE;
        break;

      // Connection options.
      case 'host':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A host name is required after '--$arg'.$usage");
        }

        ++$i;
        $options['host'] = $argv[$i];
        break;

      case 'user':
      case 'username':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A user name is required after '--$arg'.$usage");
        }

        ++$i;
        $options['username'] = $argv[$i];
        break;

      case 'password':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A password is required after '--$arg'.$usage");
        }

        ++$i;
        $options['password'] = $argv[$i];
        break;

      // Flags.
      case 'verbose':
        $options['verbose'] = TRUE;
        break;

      case 'format':
        if (($i + 1) >= $n) {
          printErrorAndExit(
            $appName,
            "A format name is required after '--$arg'.$usage");
        }

        ++$i;
        $value = $argv[$i];
        switch ($value) {
          // Principal values.
          case 'auto':
          case 'full':
          case 'keyvalue':
          case 'linux':
          case 'text':
            break;

          // Synonyms.
          case 'all':
          case 'raw':
            $value = 'full';
            break;

          case 'kv':
            $value = 'keyvalue';
            break;

          case 'macos':
          case 'osx':
          case 'unix':
          case 'bsd':
            $value = 'linux';
            break;

          case 'default':
            $value = 'auto';
            break;

          default:
            printErrorAndExit(
              $appName,
              "Unknown format name: '$value'.$usage");
            break;
        }

        $options['format'] = $value;
        break;

      default:
        // Otherwise the option is not generic.
        $a = $argv[$i];
        printErrorAndExit(
          $appName,
          "Unknown option: '--$a'.$usage");
        break;
    }
  }

  //
  // Handle version
  // --------------
  // The --version flag can be used with or without a host.
  //
  // Without a host, just show the client side's versions.
  //
  // With a host, map --version to the 'version' command.
  if ($showVersion === TRUE) {
    if (empty($options['host']) === TRUE) {
      printVersionAndExit($options);
    }

    // Override any additional command given and make it "version".
    $options['command'] = ["version"];
  }

  //
  // Validate
  // --------
  // Check that a host name has been given.
  if (empty($options['host']) === TRUE) {
    printErrorAndExit(
      $appName,
      "A host name is required. Use '--host hostname'.$usage");
  }

  return $options;
}

/**
 * Validates a command and its flags.
 *
 * @param array $options
 *   The command-line options array.
 * @param bool $exitOnError
 *   (optional, default = TRUE) When TRUE, on an error a message is output
 *   and the application exits. When FALSE, on an error a message is output
 *   and FALSE is returned.
 *
 * @return bool
 *   Returns TRUE on successful validation, and FALSE otherwise.
 */
function validateCommand(array &$options, bool $exitOnError = TRUE) {
  //
  // Recognize command
  // -----------------
  // Check if the command is recognized. It can be a primary command name
  // or one of the synonyms.
  $appName = $options['appName'];
  if ($exitOnError === TRUE) {
    $usage = "\nUse '--help' for a list of commands and options.";
  }
  else {
    $usage = "\nType 'help' for a list of commands and options.\n";
  }

  if (isset($options['command']) === FALSE) {
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "Missing command.$usage");
    }

    print("Missing command.$usage");
    return FALSE;
  }

  $commandName = reset($options['command']);
  $found = FALSE;

  if (isset(COMMANDS[$commandName]) === TRUE) {
    $found = TRUE;
  }
  else {
    // Look through the synonyms of all commands. If found, swap the
    // command name from the synonym to the primary name.
    foreach (COMMANDS as $name => &$info) {
      if (isset($info['synonyms']) === TRUE) {
        if (in_array($commandName, $info['synonyms']) === TRUE) {
          $found = TRUE;
          $commandName = $name;
          $options['command'][0] = $name;
          break;
        }
      }
    }
  }

  if ($found === FALSE) {
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "Unknown command: '$commandName'.$usage");
    }

    print("Unknown command: '$commandName'.$usage");
    return FALSE;
  }

  //
  // Check implementation
  // --------------------
  // Make sure the command has a function! If it doesn't, the command is
  // not yet implemented.
  if (isset(COMMANDS[$commandName]['function']) === FALSE) {
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "$commandName is not supported yet.");
    }

    print("$commandName is not supported yet.\n");
    return FALSE;
  }

  //
  // Handle return formats
  // ---------------------
  // Map the 'auto' return type to the actual type.
  if ($options['format'] === 'auto') {
    $options['format'] = COMMANDS[$commandName]['defaultFormat'];
  }

  // Check that only valid return types were provided.
  if (empty(COMMANDS[$commandName]['formats']) === FALSE &&
      in_array($options['format'], COMMANDS[$commandName]['formats']) === FALSE) {
    $rt = $options['format'];
    if ($exitOnError === TRUE) {
      printErrorAndExit(
        $appName,
        "Unsupported format name '$rt' for '$commandName'.$usage");
    }

    print("Unsupported format name '$rt' for '$commandName'.$usage");
    return FALSE;
  }

  //
  // Parse flags and paths
  // ---------------------
  // Check that the flags make sense.
  $pathsAndFlags = parseCommandFlags(
    $appName,
    $commandName,
    $options['command']);
  if ($pathsAndFlags === FALSE) {
    return FALSE;
  }

  $options['paths'] = $pathsAndFlags['paths'];
  $options['flags'] = $pathsAndFlags['flags'];

  return TRUE;
}

/**
 * Parses flags for a specific command.
 *
 * An array arguments for a command is split into:
 * - Flags that start with '-' or '--'.
 * - Paths or other non-dash arguments.
 *
 * Flags are parsed for the command and errors generated for unrecognized
 * flags.
 *
 * Flags with a single dash are presumed to be single-letter flags
 * (e.g. "-a"). If multiple letters are given, the flags are expanded
 * into multiple flags (e.g. "-abc" becomes "-a", "-b", and "-c).
 *
 * Flags with a double dash are presumed to be multi-letter word flags
 * and are not changed.
 *
 * Flag synonyms are transparently mapped to their primary names (e.g.
 * "--stuff" becomes "-s" if "-s" is the primary name).
 *
 * @param string $appName
 *   The name of the command-line application.
 * @param string $commandName
 *   The name of the command.
 * @param array $args
 *   The arguments array from the basic command-line parser.
 *
 * @return array|bool
 *   Returns an associative array with 'flags' and 'paths' keys whose
 *   values are each arrays. The 'paths' array contains a list of
 *   paths or non-flag arguments, in order. The 'flags' array contains
 *   a list of flags. Returns FALSE on error.
 */
function parseCommandFlags(string $appName, string $commandName, array $args) {
  //
  // Split args
  // ----------
  // Divide up the incoming arguments into paths and flags. A flag starts
  // with a '-' or '--', while a path does not.
  $paths = [];
  $flags = [];

  array_shift($args);
  foreach ($args as $arg) {
    // Look at the first character to decide if the argument is a flag
    // or a path.
    $dash = mb_substr($arg, 0, 1);
    if ($dash === '-') {
      $flags[] = $arg;
    }
    else {
      $paths[] = $arg;
    }
  }

  //
  // Expand flags
  // ------------
  // For single-dash options with multiple letters, split the letters into
  // separate flags. For instance "-abc" becomes "-a", "-b", and "-c".
  // Leave double-dash options alone.
  $expandedFlags = [];
  foreach ($flags as $flag) {
    // Don't expand double-dash flags.
    $firstTwo = mb_substr($flag, 0, 2);
    if ($firstTwo === '--') {
      $expandedFlags[] = $flag;
      continue;
    }

    // No need to expand flags that are one letter after '-'.
    $len = mb_strlen($flag);
    if ($len === 2) {
      $expandedFlags[] = $flag;
    }

    for ($i = 1; $i < $len; ++$i) {
      $f = mb_substr($flag, $i, 1);
      $expandedFlags[] = '-' . $f;
    }
  }

  $flags = $expandedFlags;
  unset($expandedFlags);

  //
  // Simplify flags
  // --------------
  // For all flags, map synonyms to their primary flag name.
  $flagsInfo = COMMANDS[$commandName]['flags'];

  $simplifiedFlags = [];
  foreach ($flags as $flag) {
    if (isset($flagsInfo[$flag]) === TRUE) {
      // The flag is a primary flag name.
      $simplifiedFlags[] = $flag;
    }
    else {
      $found = FALSE;
      foreach ($flagsInfo as $flagName => &$flagInfo) {
        if (isset($flagInfo['synonyms']) === TRUE) {
          foreach ($flagInfo['synonyms'] as $synonymName) {
            if ($flag === $synonymName) {
              // Map the synonym to the primary flag name.
              $simplifiedFlags[] = $flagName;
              $found = TRUE;
              break 2;
            }
          }
        }
      }

      // If the flag was not found as a synonym of anything, then
      // report an error.
      if ($found === FALSE) {
        print("$commandName: Unrecognized option \"$flag\".\n");
        return FALSE;
      }
    }
  }

  return [
    'paths' => $paths,
    'flags' => $simplifiedFlags,
  ];
}

/*--------------------------------------------------------------------
 *
 * Operations.
 *
 * These functions perform the main operations, such as getting
 * information about entities, settings, and usage, or creating
 * new entities, or changing existing entities.
 *
 *--------------------------------------------------------------------*/

/**
 * Prints host configuration parameters.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | --help        | Show help on command.                     |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 */
function runConfig(FolderShareConnect $server, array $options) {
  //
  // Execute
  // -------
  // Report configuration.
  try {
    $response = $server->getConfiguration();

    if ($options['format'] === 'text') {
      print(FolderShareFormat::formatAsConfiguration($response));
    }
    else {
      print_r($response);
    }
  }
  catch (\Exception $e) {
    $commandName = reset($options['command']);
    print("$commandName: " . $e->getMessage() . "\n");
    return FALSE;
  }

  return TRUE;
}

/**
 * Prints file, folder, and storage usage for a user.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | --help        | Show help on command.                     |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 */
function runUsage(FolderShareConnect $server, array $options) {
  //
  // Execute
  // -------
  // Report usage.
  try {
    $response = $server->getUsage();

    if ($options['format'] === 'text') {
      print(FolderShareFormat::formatAsUsage($response));
    }
    else {
      print_r($response);
    }
  }
  catch (\Exception $e) {
    $commandName = reset($options['command']);
    print("$commandName: " . $e->getMessage() . "\n");
    return FALSE;
  }

  return TRUE;
}

/**
 * Prints software version numbers.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | --help        | Show help on command.                     |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection. If the connection is NULL, only the client
 *   side's version information is returned.
 * @param array $options
 *   The command-line options array.
 * @param bool $doConnect
 *   (optional, default = TRUE) When TRUE, a request is sent to the server
 *   to get its version information, which is then merged with information
 *   about the client API and PHP version. When FALSE, no request is sent
 *   and the returned array only includes the client API and PHP version.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 */
function runVersion(
  FolderShareConnect $server,
  array $options,
  bool $doConnect = TRUE) {
  //
  // Execute
  // -------
  // Report configuration.
  try {
    $response = $server->getVersion($doConnect);

    if (is_array($response) === FALSE) {
      print_r($response);
    }
    else {
      if (isset($response['client']) === FALSE) {
        $response['client'] = [];
      }

      // Add an application entry to the front of the client version list.
      $response['client'] = array_merge([
        'application' => [
          'name'      => NAME,
          'version'   => VERSION,
        ],
      ], $response['client']);

      if ($options['format'] === 'text') {
        print(FolderShareFormat::formatAsVersion($response));
      }
      else {
        print_r($response);
      }
    }
  }
  catch (\Exception $e) {
    $commandName = reset($options['command']);
    print("$commandName: " . $e->getMessage() . "\n");
    return FALSE;
  }

  return TRUE;
}

/**
 * Prints file or folder status.
 *
 * This command emulates the Linux/macOS/BSD "stat" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -t     | Show a terse form of the information.            |
 * | --help | Show help on command.                            |
 * | --terse| Same as -t.                                      |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * Linux "stat" supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -c     | Use a custom output format.                      |
 * | -f     | Show file system status instead of file status.  |
 * | -L     | Follow symbolic links.                           |
 * | -t     | Show a terse form of the information.            |
 * | --dereference | Same as -L.                               |
 * | --filesystem  | Same as -f.                               |
 * | --format      | Same as -c.                               |
 * | --help        | Show help on command.                     |
 * | --terse       | Same as -t.                               |
 * | --version     | Show version information.                 |
 *
 * BSD and macOS "stat" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -f     | Use a custom output format.                      |
 * | -F     | Add special symbols on files and folders.        |
 * | -l     | Same as "ls -lT".                                |
 * | -L     | Follow symbolic links.                           |
 * | -n     | Suppress newline after each item.                |
 * | -q     | Suppress error messages.                         |
 * | -r     | Show raw information from the 'stat' syscall.    |
 * | -s     | Show information in a shell compatible format.   |
 * | -t     | Display time stamps in a custom output format.   |
 * | -x     | Show a verbose output format similar to Linux.   |
 *
 * BSD supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -H     | Treat arguments as hex NFS file handles.         |
 *
 * There is no POSIX "stat" command.
 *
 * The set of flags for Linux and macOS/BSD are entirely disjoint -
 * there is nothing in common. Some flags, like -t, show up in both
 * versions of "stat", but with different meanings.
 */
function runStat(FolderShareConnect $server, array $options) {
  //
  // Parse flags
  // -----------
  // Synonyms have already been mapped to primary flag names.
  $terseMode = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-t':
        $terseMode = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // If there are no paths given, default to '/'.
  $remotePaths = $options['paths'];
  if (empty($remotePaths) === TRUE) {
    $remotePaths = ['/'];
  }

  //
  // Execute
  // -------
  // Get entity information.
  foreach ($remotePaths as $remotePath) {
    try {
      $response = $server->getFileOrFolder($remotePath);

      if (empty($response) === FALSE) {
        if ($options['format'] === 'linux') {
          print(FolderShareFormat::formatAsLinuxStat($response, $terseMode));
        }
        elseif ($options['format'] === 'text') {
          print(FolderShareFormat::formatAsText($response));
        }
        else {
          print_r($response);
        }
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Prints a list of files and folders.
 *
 * This command emulates the Linux/macOS/BSD "ls" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -d     | List directories without recursion.              |
 * | -F     | Add special symbols on files and folders.        |
 * | -i     | Include the entity ID.                           |
 * | -l     | Show a long listing format.                      |
 * | -R     | Recursively list directories.                    |
 * | -s     | Include the size of each item.                   |
 * | -S     | Sort by size.                                    |
 * | -t     | Sort by modification time.                       |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * POSIX, Linux, macOS, and BSD "ls" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -1     | Force one-column output.                         |
 * | -a     | Show all entries, including "." entries.         |
 * | -c     | Show last modified time.                         |
 * | -C     | Force multi-column output.                       |
 * | -d     | List directories without recursion.              |
 * | -f     | Do not sort. Also turns on -a.                   |
 * | -F     | Add special symbols on files and folders.        |
 * | -g     | Like -l, skip owner names (just show groups).    |
 * | -i     | Include the inode number.                        |
 * | -l     | Show a long listing format.                      |
 * | -L     | Show info on symbolic link target.               |
 * | -o     | Like -l, skip group names (just show owners).    |
 * | -q     | Replace non-printing characters with ?.          |
 * | -r     | Reverse the sort order.                          |
 * | -R     | Recursively list directories.                    |
 * | -s     | Include the size of each item.                   |
 * | -t     | Sort by modification time.                       |
 * | -u     | Sort by last access time.                        |
 *
 * Linux, macOS, and BSD support the following additional flags,
 * but not POSIX:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -h     | Simplify numbers with byte suffixes (e.g. MB).   |
 *
 * Linux and macOS support the following additional flags, but
 * not BSD:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -A     | Same as -a, but skip "." and "..".               |
 * | -H     | Follow symbolic links.                           |
 * | -k     | Show sizes in kilobytes, not blocks.             |
 * | -m     | Full width output with comma separated entries.  |
 * | -n     | Like -l, show numeric IDs.                       |
 * | -p     | Append '/' to directory names.                   |
 * | -S     | Sort by size.                                    |
 * | -x     | Order values side-to-side, instead of up-and-down.|
 *
 * Linux supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -b     | Show non-printing characters with C escape codes.|
 * | -B     | Ignore backup files ending with "~".             |
 * | -D     | Generate output for Emacs dired mode.            |
 * | -G     | With -l, skip group names.                       |
 * | -I     | Suppress entries matching a pattern.             |
 * | -N     | Print raw names, including control characters.   |
 * | -Q     | Enclose names in double-quotes.                  |
 * | -T     | Set tab stops.                                   |
 * | -U     | Do not sort.                                     |
 * | -v     | Use a natural sort for numbers in text.          |
 * | -w     | Set output width.                                |
 * | -X     | Sort by file name extension.                     |
 * | --all        | Same as -a.                                |
 * | --almost-all | Same as -A.                                |
 * | --author     | With -l, print the author of each file.    |
 * | --escape     | Same as -b.                                |
 * | --block-size | Show sizes in blocks.                      |
 * | --classify   | Same as -F.                                |
 * | --color      | Colorize output.                           |
 * | --dereference| Same as -L.                                |
 * | --dereference-command-line | Same as -H.                  |
 * | --dereference-command-line-symlink-to-dir| Follow symbolic links to dirs.|
 * | --directory  | Same as -d.                                |
 * | --dired      | Same as -D.                                |
 * | --file-type  | Same as -F, but don't add '*' on executables.|
 * | --format     | Customize formatting.                      |
 * | --full-time  | Same as -l, but use full ISO times.        |
 * | --help       | Show help on command.                      |
 * | --hide       | Hide entries that match a pattern.         |
 * | --hide-control-chars| Same as -q.                         |
 * | --human-readable | Same as -h.                            |
 * | --ignore     | Same as -I.                                |
 * | --ignore-backups | Same as -B.                            |
 * | --indicator-style| Same as -p, --file-type, or -F.        |
 * | --inode      | Same as -i.                                |
 * | --literal    | Same as -N.                                |
 * | --no-group   | Same as -G.                                |
 * | --quote-name | Same as -Q.                                |
 * | --quoting-style| Same as -Q but specify quoting.          |
 * | --numeric-uid-gid | Same as -n.                           |
 * | --recursive  | Same as -R.                                |
 * | --reverse    | Same as -r.                                |
 * | --show-control-characters| Show non-printing characters as-is.|
 * | --si         | Same as -h, but use powers of 1000 not 1024.|
 * | --size       | Same as -s.                                |
 * | --sort       | Select the sort key.                       |
 * | --tabsize    | Same as -T.                                |
 * | --time       | Select different time value.               |
 * | --time-style | Select time formatting.                    |
 * | --width      | Same as -w.                                |
 * | --version    | Show version information.                  |
 *
 * macOS supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -@     | With -l, show extended attributes.               |
 * | -b     | Show non-printing characters with octal escapes. |
 * | -B     | Same as -b, but use C escape codes too.          |
 * | -e     | With -l, show ACLs.                              |
 * | -G     | Colorize output.                                 |
 * | -O     | With -l, include file flags.                     |
 * | -P     | Show in on symbolic link, not target.            |
 * | -T     | With -l, show full detailed time.                |
 * | -U     | Sort by creation time.                           |
 * | -v     | Show non-printing characters as-is.              |
 * | -w     | Force raw printing of non-printable characters.  |
 * | -W     | Show whiteouts when scanning directories.        |
 */
function runLs(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $recurse = FALSE;
  $formatFlags = [];

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-d':
        $recurse = FALSE;
        break;

      case '-R':
        $recurse = TRUE;
        break;

      case '-F':
      case '-i':
      case '-l':
      case '-s':
      case '-S':
      case '-t':
        $formatFlags[] = $flagName;
        break;
    }
  }

  //
  // Validate
  // --------
  // If there are no paths given, default to '/'.
  $remotePaths = $options['paths'];
  if (empty($remotePaths) === TRUE) {
    $remotePaths = ['/'];
  }

  if ($recurse === TRUE && $options['format'] !== 'linux') {
    $commandName = reset($options['command']);
    print("$commandName: Recursive lists must use a 'linux' output format.\n");
    return FALSE;
  }

  //
  // Execute
  // -------
  // Get a list of entities. Format the response using the flags, if any.
  while (empty($remotePaths) === FALSE) {
    $remotePath = array_shift($remotePaths);

    if ($recurse === TRUE) {
      print("$remotePath:\n");
    }

    // Get the list.
    try {
      switch ($remotePath) {
        case '/':
        case '/private':
          $response = $server->getRootFolders('private');
          break;

        case '/public':
          $response = $server->getRootFolders('public');
          break;

        case '/shared':
          $response = $server->getRootFolders('shared');
          break;

        default:
          $response = $server->getDescendants($remotePath);
          break;
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }

    // Print the response.
    if (empty($response) === FALSE) {
      switch ($options['format']) {
        case 'linux':
          print(FolderShareFormat::formatAsLinuxLs($response, $formatFlags));
          break;

        case 'text':
          print(FolderShareFormat::formatAsText($response));
          break;

        default:
          print_r($response);
      }
    }

    // Update the paths array by adding child paths to the front.
    if ($recurse === TRUE) {
      $recursePaths = [];
      if (is_array($response) === TRUE) {
        // Loop through the response and create a path for each folder item.
        foreach ($response as $r) {
          if (isset($r['path']) === TRUE && isset($r['kind']) === TRUE) {
            $k = $r['kind'];
            if ($k === 'folder' || $k === 'rootfolder') {
              $recursePaths[] = $r['path'];
            }
          }
        }
      }

      // Add recursion paths to the front of the path list.
      // This causes us to do a depth-first traversal.
      $remotePaths = ($recursePaths + $remotePaths);

      if (empty($remotePaths) === FALSE) {
        print("\n");
      }
    }
  }

  return TRUE;
}

/**
 * Deletes files and folders.
 *
 * This command emulates the Linux/macOS/BSD "rm" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -d     | Remove directories as well as files.             |
 * | -f     | Don't prompt for comfirmation and ignore errors. |
 * | -R     | Recursively delete directory trees (implies -d). |
 * | -r     | Same as -R.                                      |
 * | -v     | Print the name of each item as it is deleted.    |
 * | --help | Show help on command.                            |
 *
 * By default, this method does not remove folders. Use "-d"
 * to remove a file or folder.
 *
 * By default, this method does not recurse and will not remove
 * folders that are not empty. Use "-r" to recurse.
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * POSIX, Linux, macOS, and BSD "rm" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -f     | Don't prompt for comfirmation and ignore errors. |
 * | -i     | Interactively confirm each item before deletion. |
 * | -R     | Recursively delete directory trees (implies -d). |
 * | -r     | Same as -R.                                      |
 *
 * Linux, macOS, and BSD "rm" support the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Print the name of each item as it is deleted.    |
 *
 * macOS and BSD "rm" support the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -d     | Remove directories as well as files.             |
 * | -P     | Overwrite regular files before deleting them.    |
 * | -W     | Undelete white-out deleted files.                |
 *
 * BSD "rm" supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -I     | Interactively confirm deletes > 3 files or dirs. |
 * | -x     | Do not cross mount points during recursive delete.|
 *
 * All Linux versions of "rm" support the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -I     | Interactively confirm deletes > 3 files or dirs. |
 * | --force            | Same as -f.                          |
 * | --help             | Show help on command.                |
 * | --interactive=WHEN | Same as -i and -I.                   |
 * | --no-preserve-root | Don't prevent '/' delete.            |
 * | --one-file-system  | Same as BSD -x.                      |
 * | --preserve-root    | Do prevent '/' delete.               |
 * | --recursive        | Same as -R.                          |
 * | --verbose          | Same as -v.                          |
 * | --version          | Show version information.            |
 *
 * RedHat Linux "rm" supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -d     | Remove directories as well as files.             |
 * | --directory        | Same as -d.                          |
 *
 * CentOS Linux "rm" supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -d     | Remove directories as well as files.             |
 * | --dir  | Same as -d.                                      |
 */
function runRm(FolderShareConnect $server, array $options) {
  //
  // Parse flags
  // -----------
  // Synonyms have already been mapped to primary flag names.
  $verbose      = FALSE;
  $recurse      = FALSE;
  $fileOrFolder = FALSE;
  $ignoreErrors = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-d':
        $fileOrFolder = TRUE;
        break;

      case '-f':
        $ignoreErrors = TRUE;
        break;

      case '-r':
        $recurse = TRUE;
        $fileOrFolder = TRUE;
        break;

      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // There must be at least one path.
  if (empty($options['paths']) === TRUE) {
    $commandName = reset($options['command']);
    print("$commandName: Missing remote file path.\n");
    return FALSE;
  }

  //
  // Execute
  // -------
  // Remove each of the indicated entities.
  foreach ($options['paths'] as $remotePath) {
    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    try {
      // There is normally no response.
      if ($fileOrFolder === FALSE) {
        $response = $server->deleteFile($remotePath);
      }
      else {
        $response = $server->deleteFileOrFolder($remotePath, $recurse);
      }

      if (empty($response) === FALSE) {
        print_r($response);
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");

      if ($ignoreErrors === FALSE) {
        return FALSE;
      }
    }
  }

  return TRUE;
}

/**
 * Deletes empty folders.
 *
 * This command emulates the Linux/macOS/BSD "rmdir" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item deleted.              |
 * | --help | Show help on command.                            |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * POSIX, Linux, macOS, and BSD "rmdir" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -p     | Remove every directory on the path.              |
 *
 * Linux supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item deleted.              |
 * | --help    | Show help on command.                         |
 * | --ignore-fail-on-non-empty | Ignore non-empty errors.     |
 * | --parents | Same as -p.                                   |
 * | --verbose | Same as -v.                                   |
 * | --version | Show version information.                     |
 *
 * BSD supports the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item deleted.              |
 */
function runRmdir(FolderShareConnect $server, array $options) {
  //
  // Parse flags
  // -----------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // There must be at least one path.
  if (empty($options['paths']) === TRUE) {
    $commandName = reset($options['command']);
    print("$commandName: Missing remote file path.\n");
    return FALSE;
  }

  //
  // Execute
  // -------
  // Remove each of the indicated entities.
  foreach ($options['paths'] as $remotePath) {
    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    try {
      // There is normally no response.
      $response = $server->deleteFolder($remotePath);
      if (empty($response) === FALSE) {
        print_r($response);
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Creates a new root folder or subfolder.
 *
 * This command emulates the Linux/macOS/BSD "mkdir" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item deleted.              |
 * | --help | Show help on command.                            |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * POSIX, Linux, macOS, and BSD "mkdir" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -m     | Set the permissions mode for new directories.    |
 * | -p     | Create parent directories too, if needed.        |
 * | -v     | Show the name of each item created.              |
 *
 * Linux has the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | --help    | Show help on command.                         |
 * | --mode    | Same as -m.                                   |
 * | --parents | Same as -p.                                   |
 * | --verbose | Same as -v.                                   |
 * | --version | Show version information.                     |
 */
function runMkdir(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // There must be at least one path.
  if (empty($options['paths']) === TRUE) {
    $commandName = reset($options['command']);
    print("$commandName: Missing remote file path.\n");
    return FALSE;
  }

  //
  // Execute
  // -------
  // Create a series of directories.
  //
  // If the path is of the form /ROOT then create a root folder.
  // Otherwise if the path is of the form /ROOT/MORE... then create
  // a subfolder. This requires that we parse the path a bit here,
  // before calling the server.
  foreach ($options['paths'] as $remotePath) {
    $indexOfLastSlash = mb_strrpos($remotePath, '/');
    if ($indexOfLastSlash === FALSE) {
      // No '/' was found at all! Since paths must start with a slash,
      // this is an error.
      $commandName = reset($options['command']);
      print("$commandName: Folder paths must start with '/'.\n");
      return FALSE;
    }

    if ($indexOfLastSlash === 0) {
      // The path has only one '/' and it is at the start of the path.
      // The path therefore names a new root folder to create.
      //
      // Remove the '/' before creating the root folder.
      $name = mb_substr($remotePath, ($indexOfLastSlash + 1));
      $parentPath = '/';
    }
    else {
      // The path contains more than one '/'. Pull out the name after
      // the last '/' and the path before it, then create a subfolder.
      $name = mb_substr($remotePath, ($indexOfLastSlash + 1));
      $parentPath = mb_substr($remotePath, 0, $indexOfLastSlash);
    }

    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    try {
      // There is normally no response.
      if ($parentPath === '/') {
        $response = $server->newRootFolder($name);
      }
      else {
        $response = $server->newFolder($parentPath, $name);
      }

      if (empty($response) === FALSE) {
        print_r($response);
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Moves a file or folder to a new location.
 *
 * This command emulates the Linux/macOS/BSD "mv" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -n     | Do not overwrite an existing file.               |
 * | -v     | Show the name of each item moved.                |
 * | --help | Show help on command.                            |
 *
 * This command always recursively copies folders.
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * POSIX, Linux, macOS, and BSD "mv" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -f     | Don't prompt for comfirmation and ignore errors. |
 * | -i     | Interactively confirm each item before moving.   |
 *
 * Linux, macOS, and BSD have the following additional flags, but
 * not POSIX:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -n     | Do not overwrite an existing file.               |
 * | -v     | Show the name of each item moved.                |
 *
 * BSD has the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -h     | Do not follow target symbolic links.             |
 *
 * Linux has the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -S     | Override the usual backup suffix.                |
 * | -t     | Move everything into the target directory.       |
 * | -T     | Treat the target as a file, not a directory.     |
 * | -u     | Only move if the source is newer.                |
 * | --force       | Same as -f.                               |
 * | --help    | Show help on command.                         |
 * | --interactive | Same as -i.                               |
 * | --no-clobber  | Same as -n.                               |
 * | --no-target-directory | Same as -T.                       |
 * | --suffix      | Same as -S.                               |
 * | --target-directory | Same as -t.                          |
 * | --update  | Same as -u.                                   |
 * | --verbose | Same as -v.                                   |
 * | --version | Show version information.                     |
 */
function runMv(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;
  $overwrite = TRUE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-n':
        $overwrite = FALSE;
        break;

      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // The command has one of two forms:
  // - mv source destination
  // - mv source1 source2 source3... destination
  //
  // The first form is a degenerate case of the second that supports
  // optional renaming of the source. In that case the destination does
  // not refer to an entity that exists, yet.
  //
  // However, only the server knows whether a destination exists. So
  // we need to break this down into a loop of source-to-destination
  // operations and watch for failure.
  //
  // Confirm there are at least two paths given.
  switch (count($options['paths'])) {
    case 0:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote file paths.\n");
      return FALSE;

    case 1:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote destination file path.\n");
      return FALSE;

    default:
      $remotePaths = $options['paths'];
      $destinationPath = array_pop($remotePaths);
      break;
  }

  //
  // Execute
  // -------
  // Move a series of items to the same destination. Abort on the first error.
  foreach ($remotePaths as $remotePath) {
    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    try {
      // There is normally no response.
      $response = $server->move($remotePath, $destinationPath, $overwrite);
      if (empty($response) === FALSE) {
        print_r($response);
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Copies a file or folder to a new location.
 *
 * This command emulates the Linux/macOS/BSD "cp" command.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -n     | Do not overwrite existing files.                 |
 * | -v     | Show the name of each item copied.               |
 * | --help | Show help on command.                            |
 *
 * This command always recursively copies folders.
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * POSIX, Linux, macOS, and BSD "cp" support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -f     | Don't prompt for comfirmation and ignore errors. |
 * | -H     | With -R, follow command line symbolic links.     |
 * | -i     | Interactively confirm each item before copying.  |
 * | -L     | With -R, follow recursive symbolic links.        |
 * | -P     | With -R, don't follow symbolic links (default).  |
 * | -p     | Preserve dates, permissions, and owner on copy.  |
 * | -R     | Recursively copy trees.                          |
 *
 * Linux, macOS, and BSD have the following additional flags, but
 * not POSIX:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -a     | Same as -pPR.                                    |
 * | -n     | Do not overwrite existing files.                 |
 * | -v     | Show the name of each item copied.               |
 *
 * BSD has the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -l     | Hard link files instead of copying.              |
 * | -x     | Do not cross mount points during recursive copy. |
 *
 * macOS has the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -c     | Copy files useing clonefile.                     |
 * | -X     | Do not copy extended attributes.                 |
 *
 * Linux has the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -b     | Make a backup of each destination file.          |
 * | -d     | Same as -P --preserve=links.                     |
 * | -l     | Hard link files instead of copying.              |
 * | -n     | Do not overwrite existing files.                 |
 * | -r     | Same as -R.                                      |
 * | -s     | Symbolic link files instead of copying.          |
 * | -S     | Override backup file name suffix.                |
 * | -t     | Specify destination (target) directory.          |
 * | -T     | Treat destination as a file, not a directory.    |
 * | -u     | Copy only if the source file is newer.           |
 * | -x     | Do not cross mount points during recursive copy. |
 * | --archive| Same as -a.                                    |
 * | --backup | Same as -b.                                    |
 * | --copy-contents | Copy special files when recursive.      |
 * | --dereference   | Same as -L.                             |
 * | --force         | Same as -f.                             |
 * | --help | Show help on command.                            |
 * | --interactive   | Same as -i.                             |
 * | --link          | Same as -l.                             |
 * | --no-clobber    | Same as -n.                             |
 * | --no-dereference| Same as -P.                             |
 * | --no-preserve   | Don't preserve attributes on copy.      |
 * | --no-target-directory| Same as -T.                        |
 * | --parents       | Use full source file name under dir.    |
 * | --one-file-system| Same as -x.                            |
 * | --preserve      | Preserve specific attributes on copy.   |
 * | --recursive     | Same as -R.                             |
 * | --reflink       | Control clones.                         |
 * | --remove-directories| Remove existing destinations first. |
 * | --sparse        | Control sparse files.                   |
 * | --strip-trailing-slashes| Remove last slashes in source.  |
 * | --symbolic-link | Same as -s.                             |
 * | --suffix        | Same as -S.                             |
 * | --target-directory| Same as -t.                           |
 * | --update        | Same as -u.                             |
 * | --verbose       | Same as -v.                             |
 * | --version | Show version information.                     |
 */
function runCp(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;
  $overwrite = TRUE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-n':
        $overwrite = FALSE;
        break;

      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // The command has one of two forms:
  // - cp source destination
  // - cp source1 source2 source3... destination
  //
  // The first form is a degenerate case of the second that supports
  // optional renaming of the copy. In that case the destination does
  // not refer to an entity that exists, yet.
  //
  // However, only the server knows whether a destination exists. So
  // we need to break this down into a loop of source-to-destination
  // operations and watch for failure.
  //
  // Confirm there are at least two paths given.
  switch (count($options['paths'])) {
    case 0:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote file paths.\n");
      return FALSE;

    case 1:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote destination file path.\n");
      return FALSE;

    default:
      $remotePaths = $options['paths'];
      $destinationPath = array_pop($remotePaths);
      break;
  }

  //
  // Execute
  // -------
  // Copy a series of items to the same destination. Abort on the first error.
  foreach ($remotePaths as $remotePath) {
    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    try {
      // There is normally no response.
      $response = $server->copy($remotePath, $destinationPath, $overwrite);
      if (empty($response) === FALSE) {
        print_r($response);
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Updates file and folder field values.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item modified.             |
 * | --help | Show help on command.                            |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * There is no standard Linux/macOS/BSD command for changing file metadata.
 *
 * The Linux 'getfattr' and 'setfattr' commands get and set arbitrary file
 * metadata:
 * - getfattr -d files...
 *   Print all metadata.
 *
 * - getfattr -n fieldname files...
 *   Print the metadata for the selected field.
 *
 * - setfattr -n fieldname -v fieldvalue files...
 *   Write the metadata for the selected field.
 *
 * - setfattr -x fieldname files...
 *   Delete the metadata for the selected field.
 *
 * The Linux commands support the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -e     | Set text encoding.                               |
 * | -h     | Apply to link, not target of link.               |
 * | -m     | Only show fields that match a pattern.           |
 * | -R     | Recurse into directories.                        |
 * | -L     | Follow symbolic links.                           |
 * | -P     | Do not follow symbolic links.                    |
 * | --absolute-name | Don't remove leading '/'.               |
 * | --dump    | Same as -d.                                   |
 * | --encoding| Same as -e.                                   |
 * | --help    | Show help on command.                         |
 * | --logical | Same as -L.                                   |
 * | --match   | Same as -m.                                   |
 * | --no-dereference| Same as -h.                             |
 * | --only-values | Only print out field values.              |
 * | --physical| Same as -P.                                   |
 * | --recursive| Same as -r.                                  |
 * | --version | Show version information.                     |
 *
 * The macOS 'xattr' command gets, sets, and deletes arbitrary file metadata:
 * - xattr files...
 *   Print all metadata.
 *
 * - xattr -p fieldname files...
 *   Print the metadata for the selected field.
 *
 * - xattr -w fieldname fieldvalue files...
 *   Write the metadata for the selected field.
 *
 * - xattr -d fieldname files...
 *   Delete the metadata for the selected field.
 *
 * - xattr -c files...
 *   Clear all metadata.
 *
 * The macOS commands support the following additional flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -l     | Long form that shows field names and values.     |
 * | -r     | Recurse into directories.                        |
 * | -s     | Apply to link, not target of link.               |
 * | -v     | Show the name of each item modified.             |
 * | -x     | Print output in hex.                             |
 *
 * The BSD 'getextattr', 'lsextattr', 'rmextattr', and 'setextattr' commands
 * get, list, delete, and set arbitrary file metadata:
 * - lsextattr namespace files...
 *   Print all metadata. 'namespace' is either 'user' or 'system'.
 *
 * - getextattr namespace fieldname files...
 *   Print the metadata for the selected field.
 *
 * - setextattr namespace fieldname fieldvalue files...
 *   Write the metadata for the selected field.
 *
 * - rmextattr namespace fieldname files...
 *   Delete the metadata for the selected field.
 *
 * The BSD commands support the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -f     | Don't prompt for comfirmation and ignore errors. |
 * | -h     | Apply to link, not target of link.               |
 * | -i     | Read attributes from stdin.                      |
 * | -n     | NULL terminate output data.                      |
 * | -q     | Be quite, don't print path name or errors.       |
 * | -s     | Convert non-printing characters to escapes.      |
 * | -x     | Print output in hex.                             |
 *
 * This FolderShare "update" supports a structure similar to the Linux,
 * macOS, and BSD commands, but not identical to any of them.
 *
 * - FolderShare does not have arbitrary metadata - the fields have
 *   to be predefined by the FolderShare module, by third-party
 *   modules, or by the site administrator. So Linux/macOS/BSD-style
 *   operations to create or delete metadata fields are not meaningful.
 *
 * - The 'stat' command already outputs all entity fields. All we need
 *   here is a command to update them.
 *
 * - The Linux, macOS, and BSD commands all have a form that gives
 *   the name of a field, the value, and a list of files. We use
 *   that same form.
 */
function runUpdate(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // The command must have at least:
  // - A field name.
  // - A field value.
  // - A path.
  //
  // All further items are paths for additional entities.
  switch (count($options['paths'])) {
    case 0:
      $commandName = reset($options['command']);
      print("$commandName: Missing field name, value, and remote file path.\n");
      return FALSE;

    case 1:
      $commandName = reset($options['command']);
      print("$commandName: Missing field value and remote file path.\n");
      return FALSE;

    case 2:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote file path.\n");
      return FALSE;

    case 3:
      $remotePaths = $options['paths'];
      $fieldName = array_shift($remotePaths);
      $fieldValue = array_shift($remotePaths);
      break;

    default:
      $commandName = reset($options['command']);
      print("$commandName: Too many arguments.\n");
      return FALSE;
  }

  //
  // Execute
  // -------
  // Change a series of items.
  foreach ($remotePaths as $remotePath) {
    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    try {
      // There is normally no response.
      $response = $server->update($remotePath, $fieldName, $fieldValue);
      if (empty($response) === FALSE) {
        print_r($response);
      }
    }
    catch (\Exception $e) {
      $commandName = reset($options['command']);
      print("$commandName: " . $e->getMessage() . "\n");
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Downloads a file and folder.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item modified.             |
 * | --help | Show help on command.                            |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * There is no standard Linux/macOS/BSD command for downloading a file.
 */
function runGet(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // The command must have exactly two paths. The first is a path to a local
  // file and the second is a path to a server parent folder.
  switch (count($options['paths'])) {
    case 0:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote file path.\n");
      return FALSE;

    case 1:
      // One path: Remote. Use "." as local path.
      $remotePath = $options['paths'][0];
      $localPath = ".";
      break;

    case 2:
      // Two paths: Remote & Local.
      $remotePath = $options['paths'][0];
      $localPath = $options['paths'][1];
      break;

    default:
      $commandName = reset($options['command']);
      print("$commandName: Too many file paths.\n");
      return FALSE;
  }

  //
  // Execute
  // -------
  // Upload the file.
  try {
    if ($verbose === TRUE) {
      print("$remotePath\n");
    }

    // There is normally no response.
    $response = $server->download($remotePath, $localPath);
    if (empty($response) === FALSE) {
      print_r($response);
    }
  }
  catch (\Exception $e) {
    $commandName = reset($options['command']);
    print("$commandName: " . $e->getMessage() . "\n");
    return FALSE;
  }

  return TRUE;
}

/**
 * Uploads a local file and folder.
 *
 * This method supports the following flags:
 * | Flag   | Meaning                                          |
 * | ------ | ------------------------------------------------ |
 * | -v     | Show the name of each item modified.             |
 * | --help | Show help on command.                            |
 *
 * @param \FolderShare\FolderShareConnect $server
 *   The server connection.
 * @param array $options
 *   The command-line options array.
 *
 * @return bool
 *   Returns TRUE on success, and FALSE on failure. On failure an error
 *   message has already been output.
 *
 * @internal
 * There is no standard Linux/macOS/BSD command for uploading a file.
 */
function runPut(FolderShareConnect $server, array $options) {
  //
  // Parse options
  // -------------
  // Synonyms have already been mapped to primary flag names.
  $verbose = FALSE;

  foreach ($options['flags'] as $flagName) {
    switch ($flagName) {
      case '-v':
        $verbose = TRUE;
        break;
    }
  }

  //
  // Validate
  // --------
  // The command must have exactly two paths. The first is a path to a local
  // file and the second is a path to a server parent folder.
  switch (count($options['paths'])) {
    case 0:
      $commandName = reset($options['command']);
      print("$commandName: Missing local and remote file paths.\n");
      return FALSE;

    case 1:
      $commandName = reset($options['command']);
      print("$commandName: Missing remote file path.\n");
      return FALSE;

    case 2:
      $localPath = $options['paths'][0];
      $remotePath = $options['paths'][1];
      break;

    default:
      $commandName = reset($options['command']);
      print("$commandName: Too many file paths.\n");
      return FALSE;
  }

  //
  // Execute
  // -------
  // Upload the file.
  try {
    if ($verbose === TRUE) {
      print("$localPath\n");
    }

    // There is normally no response.
    $response = $server->upload($localPath, $remotePath);
    if (empty($response) === FALSE) {
      print_r($response);
    }
  }
  catch (\Exception $e) {
    $commandName = reset($options['command']);
    print("$commandName: " . $e->getMessage() . "\n");
    return FALSE;
  }

  return TRUE;
}

/*--------------------------------------------------------------------
 *
 * Execute!
 *
 * Run the application.
 *
 *--------------------------------------------------------------------*/

//
// Parse the command line. There may not be a command.
//
$options = parseCommandLine($argv);
$appName = $options['appName'];


//
// Open server connection
// ----------------------
// If needed, prompt for the user name and password. Then use the given
// host and open a server connection and set the return format and
// verbosity level.
try {
  // Prompt for user name.
  if (empty($options['username']) === TRUE) {
    print("Username: ");
    $options['username'] = stream_get_line(STDIN, 1024, PHP_EOL);
  }

  // Prompt for password.
  if (empty($options['password']) === TRUE) {
    print("Password: ");
    $options['password'] = stream_get_line(STDIN, 1024, PHP_EOL);
  }

  // Open server connection.
  $server = new FolderShareConnect();

  // Enable/disable verbosity.
  if ($options['verbose'] === TRUE) {
    $server->setVerbose(TRUE);
  }

  // Set the host.
  $server->setHostName($options['host']);

  // Log in.
  //
  // Provide the user name and password to log in. This typically triggers
  // a connection. It will fail if the host, user name, or password are bad,
  // or if there are problems communicating with the host.
  if ($server->login($options['username'], $options['password']) === FALSE) {
    printErrorAndExit($appName, "Login failed.");
  }
}
catch (\Exception $e) {
  printErrorAndExit($appName, $e->getMessage());
}

//
// Execute single command
// ----------------------
// If a command was given on the command line, execute it.
if (empty($options['command']) === FALSE) {
  //
  // Validate command
  // ----------------
  // If a command is given, it must be valid.
  // - Check if the command is a primary name or a synonym.
  // - Check that there is a function for the command.
  // - Check that the return format is supported.
  // - Check that the given flags make sense.
  if (empty($options['command']) === FALSE) {
    validateCommand($options);
  }

  if (in_array('--help', $options['flags']) === TRUE) {
    printCommandHelp($appName, $options['command']);
    exit(0);
  }

  // Set the preferred return format.
  if ($options['format'] === 'linux' || $options['format'] === 'text') {
    $server->setReturnFormat('keyvalue');
  }
  else {
    $server->setReturnFormat($options['format']);
  }

  try {
    //
    // Dispatch
    // --------
    // Invoke the command.
    $commandName = reset($options['command']);
    $status = COMMANDS[$commandName]['function']($server, $options);
    exit(($status === TRUE) ? 0 : 1);
  }
  catch (\Exception $e) {
    printErrorAndExit($appName, $e->getMessage());
  }
}

//
// Execute multiple commands
// -------------------------
// Enter a prompt loop and execute commands as given.
print("Foldershare shell.\nType 'help' for a list of commands, 'quit' to exit.\n");
while (TRUE) {
  try {
    //
    // Prompt
    // ------
    // Get a single line of input.
    $prompt = "$appName> ";
    if (PHP_OS === 'WINNT') {
      $line = stream_get_line(STDIN, 1024, PHP_EOL);
    }
    else {
      $line = readline($prompt);
    }

    if ($line === FALSE) {
      // EOF.
      break;
    }

    if (empty($line) === TRUE) {
      continue;
    }

    if (PHP_OS !== 'WINNT') {
      readline_add_history($line);
    }

    //
    // Split into arguments
    // --------------------
    // Quotes require special handling to keep values together as a single
    // argument.
    $parts = mb_split('["\']', $line);
    $inQuoted = FALSE;
    $args = [];
    foreach ($parts as $part) {
      if ($inQuoted === TRUE) {
        // This part is a quoted string, with the quotes removed. Do not
        // trim or change in any way.
        $args[] = $part;
        $inQuoted = FALSE;
      }
      else {
        // The part is one or more non-quoted arguments. Remove redundant
        // white space, then split into arguments at white space boundaries.
        foreach (mb_split(' ', mb_ereg_replace('\s+', ' ', $part)) as $p) {
          if (empty($p) === FALSE) {
            $args[] = $p;
          }
        }
        $inQuoted = TRUE;
      }
    }

    // Build an options array.
    $localOptions = $options;
    $localOptions['command'] = $args;

    $commandName = reset($localOptions['command']);
    switch ($commandName) {
      case 'help':
        printPromptHelp($appName);
        continue 2;

      case 'quit':
        exit(0);
    }

    //
    // Validate command
    // ----------------
    // If a command is given, it must be valid.
    // - Check if the command is a primary name or a synonym.
    // - Check that there is a function for the command.
    // - Check that the return format is supported.
    // - Check that the given flags make sense.
    if (validateCommand($localOptions, FALSE) === FALSE) {
      continue;
    }

    $commandName = reset($localOptions['command']);

    if (in_array('--help', $localOptions['flags']) === TRUE) {
      printCommandHelp($appName, $commandName);
      continue;
    }

    // Set the preferred return format.
    if ($localOptions['format'] === 'linux' ||
        $localOptions['format'] === 'text') {
      $server->setReturnFormat('keyvalue');
    }
    else {
      $server->setReturnFormat($localOptions['format']);
    }

    //
    // Dispatch
    // --------
    // Invoke the command.
    COMMANDS[$commandName]['function']($server, $localOptions);
  }
  catch (\Exception $e) {
    print($e->getMessage());
  }
}
